<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
<channel>
  <title>南有嘉鱼</title>
  <description>南有嘉鱼 - </description>
  <atom:link href="https://dyxu.net/rss.xml" rel="self" type="application/rss+xml"/>
  <link>https://dyxu.net</link>
  <lastBuildDate>Sat, 25 Jun 2022 14:34:07 +0000</lastBuildDate>
  <pubDate>Sat, 25 Jun 2022 14:34:07 +0000</pubDate>
  <ttl>1800</ttl>


  <item>
    <title>Max-Min Fairness算法及边缘计算应用</title>
    <description>
&lt;pre&gt;&lt;code&gt;调度系统中算法设计往往对资源利用率起着关键作用。软件设计没有银弹，算法的优劣往往依赖于对应的业务场景。
该系列文章将整理几种资源调度算法，并分析算法的特性，适用场景等，最后分享在边缘云调度场景中的应用。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;1-前言&quot;&gt;1 前言&lt;/h2&gt;
&lt;p&gt;Max-Min Fairness（MMF）是一种兼顾公平的前提下，尽可能让更多人满意的资源分配算法。常用于单一共享资源的分配场景，如多路复用的通信系统中多任务共享信道传输。算法的优势在于有着较高的平均吞吐量和资源利用率，同时算法稳定性高，单一任务突发不容易影响其他任务&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。算法的劣势在于一般只适用于单一共享资源。&lt;/p&gt;

&lt;p&gt;边缘计算场景中，边缘网络节点带宽上联有限，多应用共享上联时与多路复用通信系统类似，存在带宽资源争抢问题。本文结合边缘云调度在节点上混部多类型应用场景中节点共享带宽资源解决方案，介绍 MMF 算法的原理和应用。&lt;/p&gt;

&lt;h2 id=&quot;2-max-min-fairness-算法&quot;&gt;2 Max-Min Fairness 算法&lt;/h2&gt;
&lt;h3 id=&quot;21-常规-mmf&quot;&gt;2.1 常规 MMF&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;
在任务调度系统中，有一个共享资源（如：CPU、带宽等），它的容量是\(C\)（capacity），每个任务\(i\)对资源的需求量为\(r_i\)（Reqeust），问如何尽量公平地分配资源？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;算法流程：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将资源平均分成\(n\)份，每份都是\(C/n\)，把每份分给相应的让任务\(r_i\)。&lt;/li&gt;
  &lt;li&gt;如果任务分配到的资源超过自己的需求量，回收超过这部分资源\(C/n-r_i\)。&lt;/li&gt;
  &lt;li&gt;将上一轮中回收的所有资源，再平均分给上一轮分配中未得到满足的任务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;举个例子&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;：&lt;/strong&gt;
如下图所示，在网络系统中带宽上限为 C = 10 Mbps，有四个任务对带宽需求分别为[2, 2.6, 4, 5] Mbps，问如何分配带宽资源？
算法流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将资源均分为4份，每份为10/4=2.5，依次将资源分给任务。&lt;/li&gt;
  &lt;li&gt;任务1需求2，分配到2.5，回收0.5；任务2到4需求空缺[0.1, 1.5, 2.5]。&lt;/li&gt;
  &lt;li&gt;将回收的资源0.5再分配给任务2到4，重复过程1-3，直到资源分配完，或者任务需求都满足。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/max-min-fairness.png&quot; alt=&quot;max-min-fairness&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-加权-mmf&quot;&gt;2.2 加权 MMF&lt;/h3&gt;

&lt;p&gt;在MMF的基础上，我们再考虑一个复杂的场景，在调度系统中每个任务的重要性或者优先级都不一样，那么系统如何考虑优先级的情况下来分配资源呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;
在任务调度系统中，有一个共享资源（如：CPU、带宽等），它的容量是\(C\)（capacity），每个任务\(i\)对资源的需求量为\(r_i\)（Reqeust），权重为\(w_i\)（Weight），问考虑权重如何“公平”地分配资源？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;算法流程：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;令\(W=\sum_{i=1}^n{w_i}\)，将资源按照权重分成\(n\)份，每份分别为\(C*w_i/W\)，把每份分给对应的任务\(r_i\)。&lt;/li&gt;
  &lt;li&gt;如果任务分配到的资源超过自己的需求量，回收超过这部分资源\(C*w_i/W - r_i\)。&lt;/li&gt;
  &lt;li&gt;将上一轮中回收的所有资源，再分给上一轮分配中未得到满足的任务，重复过程1-3，直到资源分配完，或者任务需求都满足。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;举个例子&lt;sup id=&quot;fnref:2:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;：&lt;/strong&gt;
如下图所示，在网络系统中带宽上限为 C = 10 Mbps，有四个任务对带宽需求分别为[3, 3, 4, 5] Mbps，权重分别为[1, 2, 1, 1], 问如何分配带宽资源？
算法流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;总权重W=5，将资源按照权重分为4份，分别为[2, 4, 2, 2]， 依次将资源分给任务。&lt;/li&gt;
  &lt;li&gt;任务1需求3，分配到2，回收0，任务2需求3，分配到4，回收1等等；任务1-4需求空缺[1，0， 2， 3]。&lt;/li&gt;
  &lt;li&gt;将回收的资源1再按权重分配给任务1，3，4，重复过程1-3，直到资源分配完，或者任务需求都满足。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/weighted-max-min-fairness.png&quot; alt=&quot;weighted-max-min-fairness&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-算法实现c&quot;&gt;2.3 算法实现C++&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;// alloc_max_min_fairness MMF算法分配资源
// @cap：资源容量
// @reqs: 资源需求列表
// @w: 不同资源需求的权重

// @return: 资源分配列表
vector&amp;lt;double&amp;gt; alloc_max_min_fairness(double cap, vector&amp;lt;double&amp;gt; reqs, vector&amp;lt;double&amp;gt; w) {
    int n = reqs.size();
    const double eps = 1e-8;
    vector&amp;lt;double&amp;gt; allocs(n, 0.0);
    set&amp;lt;int&amp;gt; exist;
    for (int i = 0; i &amp;lt; n; i++) {
        exist.insert(i);
    }

	// 资源分配完或者需求都满足
    while (abs(cap) &amp;gt; eps &amp;amp;&amp;amp; !exist.empty()) {
        double sum = 0;
        for (int i: exist) {
            sum += w[i];
        }
        // 按权重均分资源
        double unit = cap / sum;
        for (auto it = exist.begin(); it != exist.end();) {
            int i = *it;
            double alloc = unit * w[i];
            if (alloc + allocs[i] &amp;gt;= reqs[i]) {
	            // 分配超出需求，回收超过部分
                alloc = reqs[i] - allocs[i];
                exist.erase(it++);
            } else {
                it++;
            }
            cap -= alloc;
            allocs[i] += alloc;
        }
    }

    return allocs;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;3-边缘云调度应用&quot;&gt;3 边缘云调度应用&lt;/h2&gt;
&lt;p&gt;相较于传统云计算业务的计算密集，边缘计算往往是流量带来了计算，流量是边缘云调度时重点关注的资源之一。相对于应用来说，云中心机房带宽能力基本可以认为是无限大，主要关注计算涉及的CPU、内存和存储等。边缘机房的特点是单节点能力小，数量多，分布广。以阿里云边缘云为例，全网平均2800个网络节点分布在全球，单节点服务能力小。&lt;/p&gt;

&lt;p&gt;所以，考虑边缘节点多应用带宽复用时，就可以参考MMF算法进行设计，能达到很不错的效果。&lt;/p&gt;

&lt;h2 id=&quot;4-总结&quot;&gt;4 总结&lt;/h2&gt;

&lt;p&gt;本文结合边缘计算场景，介绍了MMF算法及其应用。算法具备不错的平均吞吐量、资源利用率和稳定性，但是局限于单一共享资源的分配，如内存等无法共享的资源则不适用。&lt;/p&gt;

&lt;h2 id=&quot;5-参考资料&quot;&gt;5 参考资料&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Max-min_fairness&quot;&gt;Max-Min Fairness - Wikipedia&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.mathcs.emory.edu/~cheung/Courses/558/Syllabus/11-Fairness/Fair.html&quot;&gt;Max-Min Fairness&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:2:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
    <link>https://dyxu.net/%E6%8A%80%E6%9C%AF/max-min-fairness.html</link>
    <guid>https://dyxu.net/%E6%8A%80%E6%9C%AF/max-min-fairness</guid>
    <pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>图算法总结</title>
    <description>
&lt;h1 id=&quot;图算法总结&quot;&gt;图算法总结&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;编程的通用模式：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;问题理解和建模。&lt;/li&gt;
  &lt;li&gt;分解子问题，简化复杂度。&lt;/li&gt;
  &lt;li&gt;逐个解决子问题，解决主问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文尝试用尽量短的文字概况问题的核心，总结LeetCode中图算法题目。&lt;/p&gt;

&lt;h2 id=&quot;经典图算法&quot;&gt;经典图算法&lt;/h2&gt;

&lt;h3 id=&quot;图的搜索&quot;&gt;图的搜索&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;DFS（深度优先搜索）&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void bfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; G, vector&amp;lt;bool&amp;gt;&amp;amp; seen, int u) {
	if (减枝条件) {
		return;
	}
	if (满足答案) {
		// 记录结果
		return;
	}
	
	// 访问节点u
	seen[u] = true;
	for (int v: G[u]) {
		// 访问边 u-&amp;gt;v
		dfs(G, seen, v);
		// 回溯边 u-&amp;gt;v
	}
	// 回溯节点u
	seen[u] = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;BFS（广度优先搜索）&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void bfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; G, int src) {
    queue&amp;lt;int&amp;gt; q;
	vector&amp;lt;bool&amp;gt; seen(G.size());
	q.push(src);
	seen[src] = true;
	int level = 0;
    while (!q.empty()) {
        int n = q.size();
		for (int i = 0; i &amp;lt; n; i++) {
			int u = q.front();
			q.pop();
			for (int v: G[u]) {
				if (!seen[v]) {
					q.push(v);
					seen[v] = true;
				}
			}
		}
		level++;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;最短路径&quot;&gt;最短路径&lt;/h3&gt;
&lt;p&gt;单源最短路径Dijkstra&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;vector&amp;lt;int&amp;gt; dijkstra(vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; &amp;amp;G, int s) {
    vector&amp;lt;int&amp;gt; dist(G.size(), INT_MAX);
    dist[s] = 0;
    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, greater&amp;lt;&amp;gt;&amp;gt; pq;
    pq.emplace(0, s);

    while (!pq.empty()) {
        auto [du, u] = pq.top();
        pq.pop();
        if (du &amp;gt; dist[u])
            continue;
        for (auto &amp;amp;[v, dv] : G[u]) {
            int d = dist[u] + dv;
            if (dist[v] &amp;gt; d) {
                dist[v] = d;
                pq.emplace(d, v);
            }
        }
    }

    return dist;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;最小生成树&quot;&gt;最小生成树&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Kruskal算法&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; kruskal(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; edges) {
    sort(edges.begin(), edges.end(),
         [](auto &amp;amp;u, auto &amp;amp;v) { return u[2] &amp;lt; v[2]; });
    UnionFind fa(n);
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; tree;
    for (auto &amp;amp;e : edges) {
        if (fa.unite(e[0], e[1])) {
            tree.push_back(e);
        }
    }

    return tree;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;计算连通性&quot;&gt;计算连通性&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;并查集&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class UnionFind {
  private:
    vector&amp;lt;int&amp;gt; _parent;
    int _count;
  public:
    UnionFind(int n): _count(n), _parent(n) {
        for (int i = 0; i &amp;lt; n; i++) {
            _parent[i] = i;
        }
    }
    int find(int x) {
        return _parent[x] == x ? x: _parent[x] = find(_parent[x]);
    }
    bool unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return false;

        _parent[y] = x;
        _count--;
        return true;
    }
    int count() const {
        return _count;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;拓扑排序&quot;&gt;拓扑排序&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;vector&amp;lt;int&amp;gt; topologySort(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; edges) {
    vector&amp;lt;int&amp;gt; order, deg(n);
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; G(n);
    for (auto&amp;amp; e: edges) {
        G[e[0]].push_back(e[1]);
        deg[e[1]]--;
    }

    queue&amp;lt;int&amp;gt; q;
    for (int i = 0; i &amp;lt; n; i++) {
        if (deg[i] == 0) {
            q.push(i);
            order.push_back(i);
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : G[u]) {
            deg[v]--;
            if (deg[v] == 0) {
                order.push_back(v);
                q.push(v);
            }
        }
    }

    return order;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;图算法题&quot;&gt;图算法题&lt;/h2&gt;
&lt;h3 id=&quot;2065-最大化一张图中的路径价值&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/maximum-path-quality-of-a-graph/&quot;&gt;2065. 最大化一张图中的路径价值&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;问题理解
    &lt;blockquote&gt;
      &lt;p&gt;给定无向图、点和边的权值，求包含0节点的环中，满足边权不超过maxTime的点权最大值。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;建模和解决
    &lt;blockquote&gt;
      &lt;p&gt;建有向图，回溯法遍历所有节点。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;代码
    &lt;blockquote&gt;
      &lt;p&gt;时间复杂度：&lt;code&gt;O(N+M)&lt;/code&gt;，M是边数，N是节点数。
空间复杂度：&lt;code&gt;O(N+M)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class Solution {
public:
    int maximalPathQuality(vector&amp;lt;int&amp;gt;&amp;amp; values, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; edges, int maxTime) {
        int n = values.size();
        vector&amp;lt;vector&amp;lt;PII&amp;gt;&amp;gt; G(n);
        for (auto&amp;amp; e: edges) {
            G[e[0]].emplace_back(e[1], e[2]);
            G[e[1]].emplace_back(e[0], e[2]);
        }
        vector&amp;lt;int&amp;gt; seen(n);
        seen[0] = true;
        int ans = 0;
        function&amp;lt;void(int, int, int)&amp;gt; dfs = [&amp;amp;](int u, int time, int value) {
            if (u == 0) {
                ans = max(ans, value);
            }
            for (auto&amp;amp; [v, dist]: G[u]) {
                if (time + dist &amp;lt;= maxTime) {
                    if (!seen[v]) {
                        seen[v] = true;
                        dfs(v, time + dist, value + values[v]);
                        seen[v] = false;
                    } else {
                        dfs(v, time + dist, value);
                    }
                }
            }
        };

        dfs(0, 0, values[0]);

        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;1632-矩阵转换后的秩&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/rank-transform-of-a-matrix/&quot;&gt;1632. 矩阵转换后的秩&lt;/a&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;问题理解
    &lt;blockquote&gt;
      &lt;p&gt;秩定义了坐标（i，j）间的依赖关系，计算矩阵的秩。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;建模和解决
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;以坐标&lt;code&gt;（i，j）=&amp;gt; i*m+i&lt;/code&gt;为节点建有向图，边为秩定义建立。&lt;/li&gt;
        &lt;li&gt;同一行和同一列中相同value的节点（利用并查集）属于同一个连通分量，排序后建立值小节点连通分量到值大节点的分量的边。&lt;/li&gt;
        &lt;li&gt;拓扑排序时，初始秩为1，存在 &lt;code&gt;u-&amp;gt;v&lt;/code&gt;的边，则&lt;code&gt;R(v) = max(R[v], R[u]+1)&lt;/code&gt;，类似于&lt;a href=&quot;https://leetcode.cn/problems/parallel-courses-iii/&quot;&gt;2050. 并行课程 III&lt;/a&gt;&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;代码
    &lt;blockquote&gt;
      &lt;p&gt;时间复杂度：&lt;code&gt;O(NMlog(max(NM)))&lt;/code&gt;，N、M为矩阵行列。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;using PII = pair&amp;lt;int, int&amp;gt;;

class UnionFind {
  private:
    vector&amp;lt;int&amp;gt; _parent;
    int _count;
  public:
    UnionFind(int n): _count(n), _parent(n) {
        for (int i = 0; i &amp;lt; n; i++) {
            _parent[i] = i;
        }
    }
    int find(int x) {
        return _parent[x] == x ? x: _parent[x] = find(_parent[x]);
    }
    bool unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return false;

        _parent[y] = x;
        _count--;
        return true;
    }
    int count() const {
        return _count;
    }
};

class Solution {
  public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; matrixRankTransform(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;mat) {
        int n = mat.size(), m = mat[0].size();
        UnionFind uf(n*m);
		
		// row range
        for (int i = 0; i &amp;lt; n; i++) {
            unordered_map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; mm; // value =&amp;gt; [i*m+j];
            for (int j = 0; j &amp;lt; m; j++) {
                mm[mat[i][j]].push_back(i*m+j);
            }
            for (auto&amp;amp; [val, idxs]: mm) {
                for (int k = 1; k &amp;lt; idxs.size(); k++) {
                    uf.unite(idxs[k - 1], idxs[k]);
                }
            }
        }
		
		// column range
        for (int j = 0; j &amp;lt; m; j++) {
            unordered_map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; mm; // value =&amp;gt; [i*m+j];
            for (int i = 0; i &amp;lt; n; i++) {
                mm[mat[i][j]].push_back(i*m+j);
            }
            for (auto &amp;amp;[val, idxs] : mm) {
                for (int k = 1; k &amp;lt; idxs.size(); k++) {
                    uf.unite(idxs[k - 1], idxs[k]);
                }
            }
        }

        // build graph
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; G(n*m);
        vector&amp;lt;int&amp;gt; deg(n*m);
        for (int i = 0; i &amp;lt; n; i++) {
            vector&amp;lt;PII&amp;gt; nums; // value =&amp;gt; index
            for (int j = 0; j &amp;lt; m; j++) {
                nums.emplace_back(mat[i][j], i*m+j);
            }
            sort(nums.begin(), nums.end());
            for (int k = 1; k &amp;lt; nums.size(); k++) {
                if (nums[k-1].first &amp;lt; nums[k].first) {
                    int u = uf.find(nums[k - 1].second);
                    int v = uf.find(nums[k].second);
					// build edge by order
                    G[u].push_back(v);
                    deg[v]++;
                }
            }
        }
        for (int j = 0; j &amp;lt; m; j++) {
            vector&amp;lt;PII&amp;gt; nums; // value =&amp;gt; index
            for (int i = 0; i &amp;lt; n; i++) {
                nums.emplace_back(mat[i][j], i * m + j);
            }
            sort(nums.begin(), nums.end());
            for (int k = 1; k &amp;lt; nums.size(); k++) {
                if (nums[k - 1].first &amp;lt; nums[k].first) {
                    int u = uf.find(nums[k - 1].second);
                    int v = uf.find(nums[k].second);
                    G[u].push_back(v);
                    deg[v]++;
                }
            }
        }
		
		// topology sort
        queue&amp;lt;int&amp;gt; q;
        for (int i = 0; i &amp;lt; n * m; i++) {
            if (deg[i] == 0 &amp;amp;&amp;amp; uf.find(i) == i) {
                q.push(i);
            }
        }

        vector&amp;lt;int&amp;gt; r(n*m, 1);
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v: G[u]) {
				// dp
                r[v] = max(r[v], r[u]+1);
                deg[v]--;
                if (deg[v] == 0) {
                    q.push(v);
                }
            }
        }

        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res(n, vector&amp;lt;int&amp;gt;(m));
        for (int i = 0; i &amp;lt; n; i++) {
            for (int j = 0; j &amp;lt; m; j++) {
                res[i][j] = r[uf.find(i*m+j)];
            }
        }

        return res;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2203-得到要求路径的最小带权子图&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/&quot;&gt;2203. 得到要求路径的最小带权子图&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;问题理解
    &lt;blockquote&gt;
      &lt;p&gt;带权有向图，求解从src1，src2到dst路径组成的最小子图。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;建模和解决
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;最短路问题，分别以src1、src2和dst计算单源最短路。&lt;/li&gt;
        &lt;li&gt;以某一个节点为中继，枚举最小子图。&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;代码
    &lt;blockquote&gt;
      &lt;p&gt;时间复杂度：&lt;code&gt;O(N+Mlog(M))&lt;/code&gt;，N、M分别为节点和边数。
空间复杂度：&lt;code&gt;O(NM)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;using PII = pair&amp;lt;int, int&amp;gt;;
class Solution {
  public:
    vector&amp;lt;long&amp;gt; dijkstra(vector&amp;lt;vector&amp;lt;PII&amp;gt;&amp;gt;&amp;amp; G, int s) {
        vector&amp;lt;long&amp;gt; dist(G.size(), LONG_MAX/3);
        dist[s] = 0;
        priority_queue&amp;lt;pair&amp;lt;long, int&amp;gt;, vector&amp;lt;pair&amp;lt;long, int&amp;gt;&amp;gt;, greater&amp;lt;&amp;gt;&amp;gt; pq;
        pq.emplace(0, s);

        while (!pq.empty()) {
            auto [du, u] = pq.top();
            pq.pop();
            if (du &amp;gt; dist[u]) continue;
            for (auto&amp;amp; [v, dv]: G[u]) {
                long d = dist[u] + dv;
                if (dist[v] &amp;gt; d) {
                    dist[v] = d;
                    pq.emplace(d, v);
                }
            }
        }

        return dist;
    }

    long long minimumWeight(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;edges, int src1, int src2, int dest) {
        vector&amp;lt;vector&amp;lt;PII&amp;gt;&amp;gt; G(n), RG(n);
        for (auto&amp;amp; e: edges) {
            int u = e[0], v = e[1], d = e[2];
            G[u].emplace_back(v, d);
            RG[v].emplace_back(u, d);
        }

        auto da = dijkstra(G, src1);
        auto db = dijkstra(G, src2);
        auto dc = dijkstra(RG, dest);

        long res = LONG_MAX/3;
        for (int i = 0; i &amp;lt; n; i++) {
            res = min(res, da[i]+db[i]+dc[i]);
        }

        return res &amp;lt; LONG_MAX/3 ? res: -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;1489-找到最小生成树里的关键边和伪关键边&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/&quot;&gt;1489. 找到最小生成树里的关键边和伪关键边&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;问题理解
    &lt;blockquote&gt;
      &lt;p&gt;带权无向图中求关键边（去除边最小生成树权重增大）和伪关键边（去除边不影响最小生成树）。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;建模和解决
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;计算最小生成树，记录最小边权。&lt;/li&gt;
        &lt;li&gt;枚举每条边，判断关键和伪关键边性质。&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;代码
    &lt;blockquote&gt;
      &lt;p&gt;时间复杂度：&lt;code&gt;O(M^2\alpha(N))&lt;/code&gt;，N、M分别为节点和边数。
空间复杂度：&lt;code&gt;O(N+M)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;using VII = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;;

class UnionFind {
  private:
    vector&amp;lt;int&amp;gt; _parent;
    int _count;
  public:
    UnionFind(int n): _count(n), _parent(n) {
        for (int i = 0; i &amp;lt; n; i++) {
            _parent[i] = i;
        }
    }
    int find(int x) {
        return _parent[x] == x ? x: _parent[x] = find(_parent[x]);
    }
    bool unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return false;

        _parent[y] = x;
        _count--;
        return true;
    }
    int count() const {
        return _count;
    }
};

class Solution {
  public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findCriticalAndPseudoCriticalEdges(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;edges) {
        int m = edges.size();
        for (int i = 0; i &amp;lt; m; i++) {
            edges[i].push_back(i);
        }
        int minValue = 0;
        sort(edges.begin(), edges.end(), [](auto&amp;amp; x, auto&amp;amp; y) {
            return x[2] &amp;lt; y[2];
        });
        UnionFind fa(n);
        for (auto&amp;amp; e: edges) {
            if (fa.unite(e[0], e[1])) {
                minValue += e[2];
            }
        }

        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res(2);
        for (int i = 0; i &amp;lt; m; i++) {
            int value = 0;
            UnionFind fb(n);
            for (int k = 0; k &amp;lt; m; k++) {
                if (i != k &amp;amp;&amp;amp; fb.unite(edges[k][0], edges[k][1])) {
                    value += edges[k][2];
                }
            }
            if (fb.count() != 1 || (fb.count() == 1 &amp;amp;&amp;amp; value &amp;gt; minValue)) {
                res[0].push_back(edges[i][3]);
                continue;
            }

            UnionFind fc(n);
            fc.unite(edges[i][0], edges[i][1]);
            value = edges[i][2];
            for (int k = 0; k &amp;lt; m; k++) {
                if (i != k &amp;amp;&amp;amp; fc.unite(edges[k][0], edges[k][1])) {
                    value += edges[k][2];
                }
            }
            if (value == minValue) {
                res[1].push_back(edges[i][3]);
            }
        }

        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2050-并行课程-iii&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/parallel-courses-iii/&quot;&gt;2050. 并行课程 III&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;问题理解
    &lt;blockquote&gt;
      &lt;p&gt;课程相互依赖，并且修完耗费一定时间，求解修完所有课的最短时间。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;建模和解决
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;典型的拓扑排序问题。&lt;/li&gt;
        &lt;li&gt;动态规划解决课程开始的最短时间，存在&lt;code&gt;u-&amp;gt;v&lt;/code&gt;边，则start[v] = max(start[v], start[u] + time[v])。&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;代码
    &lt;blockquote&gt;
      &lt;p&gt;时间复杂度：&lt;code&gt;O(N+M)&lt;/code&gt;，N、M分别为节点和边数。
空间复杂度：&lt;code&gt;O(N+M)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class Solution {
public:
  int minimumTime(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;relations, vector&amp;lt;int&amp;gt; &amp;amp;time) {
      vector&amp;lt;int&amp;gt; start(n), deg(n);
      VII G(n);
      for (auto&amp;amp; e: relations) {
          G[e[0]-1].push_back(e[1]-1);
          deg[e[1]-1]++;
      }
      queue&amp;lt;int&amp;gt; q;
      for (int i = 0; i &amp;lt; n; i++) {
          if (deg[i] == 0) {
              q.push(i);
          }
      }
      int ans = 0;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          ans = max(ans, start[u]+time[u]);
          for (int v: G[u]) {
              deg[v]--;
              start[v] = max(start[v], start[u] + time[u]);
              if (deg[v] == 0) {
                  q.push(v);
              }
          }
      }

      return ans;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;1928-规定时间内到达终点的最小花费&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/&quot;&gt;1928. 规定时间内到达终点的最小花费&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;问题理解
    &lt;blockquote&gt;
      &lt;p&gt;点和边都带权的无向图，求救从0出发到n-1，且边权不大于maxTime的最小点权值。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;建模和解决
    &lt;blockquote&gt;
      &lt;p&gt;回溯+剪枝。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;代码&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;using MII = unordered_map&amp;lt;int, int&amp;gt;;

class Solution {
private:
    int _cost = 0;
    int _costTime = 0;
    int _minCost = INT_MAX;
    int _maxTime, _n;
    vector&amp;lt;MII&amp;gt; _G;
    vector&amp;lt;int&amp;gt; _fees;
    vector&amp;lt;bool&amp;gt; _seen;
    vector&amp;lt;int&amp;gt; _minPathTime, _minPathCost;
public:
    int minCost(int maxTime, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;edges, vector&amp;lt;int&amp;gt; &amp;amp;fees) {
        _n = fees.size();
        _G.resize(_n);
        _fees = fees;
        _seen.resize(_n);
        _minPathCost = vector&amp;lt;int&amp;gt;(_n, INT_MAX);
        _minPathTime = vector&amp;lt;int&amp;gt;(_n, INT_MAX);
        for (auto&amp;amp; e: edges) {
            if (_G[e[1]].count(e[0])) {
                _G[e[1]][e[0]] = min(_G[e[1]][e[0]], e[2]);
                _G[e[0]][e[1]] = min(_G[e[0]][e[1]], e[2]);
            } else {
                _G[e[0]][e[1]] = _G[e[1]][e[0]] = e[2];
            }
        }
        _maxTime = maxTime;
        backtrack(0);
        return _minCost == INT_MAX ? -1: _minCost;

    }

    void backtrack(int u) {
		// 剪枝很关键
        if (_costTime &amp;gt; _maxTime || _cost &amp;gt; _minCost || (_cost &amp;gt; _minPathCost[u] &amp;amp;&amp;amp; _costTime &amp;gt; _minPathTime[u])) {
            return;;
        }
        if (u == _n-1) {
            _minCost = min(_minCost, _cost+_fees[u]);
            return;
        }

        _seen[u] = true;
        _cost += _fees[u];
        _minPathCost[u] = min(_minPathCost[u], _cost);
        _minPathTime[u] = min(_minPathTime[u], _costTime);
        for (auto&amp;amp; v: _G[u]) {
            if (!_seen[v.first]) {
                _costTime += v.second;
                backtrack(v.first);
                _costTime -= v.second;
            }
        }
        _seen[u] = false;
        _cost -= _fees[u];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2076-处理含限制条件的好友请求&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/process-restricted-friend-requests/&quot;&gt;2076. 处理含限制条件的好友请求&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;问题理解
    &lt;blockquote&gt;
      &lt;p&gt;合并连通分量时满足非连通性约束。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;建模和解决
    &lt;blockquote&gt;
      &lt;p&gt;并查集，每次合并u–v时，检查是否满足yeu’s&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;代码
    &lt;blockquote&gt;
      &lt;p&gt;时间复杂度：&lt;code&gt;O(KM\alpha(N))&lt;/code&gt;，K、M分别是请求和约束条件数目，N为节点数
空间复杂度：&lt;code&gt;O(N)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class Solution {
  private:
    vector&amp;lt;int&amp;gt; _parent;
  public:
    vector&amp;lt;bool&amp;gt; friendRequests(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;res, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;req) {
        _parent.resize(n);
        for (int i = 0; i &amp;lt; n; i++) {
            _parent[i] = i;
        }
        vector&amp;lt;bool&amp;gt; ans;
        for (auto&amp;amp; r: req) {
            int x = find(r[0]), y = find(r[1]);
            if (x == y) {
                ans.push_back(true);
            } else {
                bool ok = true;
                for (auto&amp;amp; rs: res) {
                    int u = find(rs[0]), v = find(rs[1]);
                    if ((x == u &amp;amp;&amp;amp; y == v) ||(x == v &amp;amp;&amp;amp; y == u)) {
                        ok = false;
                        break;
                    }
                }

                if (ok) {
                    unite(x, y);
                    ans.push_back(true);
                } else {
                    ans.push_back(false);
                }
            }
        }

        return ans;
    }
    int find(int x) {
        return _parent[x] == x? x: _parent[x] = find(_parent[x]);
    }
    bool unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return false;

        _parent[y] = x;
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2246-相邻字符不同的最长路径&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/&quot;&gt;2246. 相邻字符不同的最长路径&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;问题理解
    &lt;blockquote&gt;
      &lt;p&gt;附带条件的树最长直径。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;建模和解决
    &lt;blockquote&gt;
      &lt;p&gt;DFS，回溯时计算最长路径&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;代码
    &lt;blockquote&gt;
      &lt;p&gt;时间复杂度：&lt;code&gt;O(N)&lt;/code&gt;，N为节点数
空间复杂度：&lt;code&gt;O(N^2)&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class Solution {
  public:
    int longestPath(vector&amp;lt;int&amp;gt; &amp;amp;parent, string s) {
        int n = parent.size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; tree(n);
        for (int i = 1; i &amp;lt; n; i++) {
            tree[parent[i]].push_back(i);
        }
        int ans = 0;

        function&amp;lt;int(int)&amp;gt; dfs = [&amp;amp;](int u) -&amp;gt; int {
            int longest = 0;
            for (int v: tree[u]) {
                int len = dfs(v) + 1;
                if (s[u] != s[v]) {
                    ans = max(ans, longest + len);
                    longest = max(longest, len);
                }
            }

            return longest;
        };
        dfs(0);

        return ans + 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    <link>https://dyxu.net/%E7%AE%97%E6%B3%95/graph-algorithms.html</link>
    <guid>https://dyxu.net/%E7%AE%97%E6%B3%95/graph-algorithms</guid>
    <pubDate>Thu, 09 Jun 2022 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>系统设计入门【转载】</title>
    <description>
&lt;p&gt;本文在&lt;a href=&quot;https://github.com/donnemartin/system-design-primer&quot;&gt;system-design-primer&lt;/a&gt;基础上，根据自身对系统设计学习情况，收集和汇总分布式系统设计相关资料，用于后续学习和巩固。&lt;/p&gt;

&lt;h1 id=&quot;系统设计入门&quot;&gt;系统设计入门&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/jj3A5N8.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;目的&quot;&gt;目的&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;学习如何设计大型系统。&lt;/li&gt;
  &lt;li&gt;为系统设计的面试做准备。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;学习如何设计大型系统&quot;&gt;学习如何设计大型系统&lt;/h3&gt;

&lt;p&gt;学习如何设计可扩展的系统将会有助于你成为一个更好的工程师。&lt;/p&gt;

&lt;p&gt;系统设计是一个很宽泛的话题。在互联网上，&lt;strong&gt;关于系统设计原则的资源也是多如牛毛。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个仓库就是这些资源的&lt;strong&gt;组织收集&lt;/strong&gt;，它可以帮助你学习如何构建可扩展的系统。&lt;/p&gt;

&lt;h3 id=&quot;为系统设计的面试做准备&quot;&gt;为系统设计的面试做准备&lt;/h3&gt;

&lt;p&gt;在很多科技公司中，除了代码面试，系统设计也是&lt;strong&gt;技术面试过程&lt;/strong&gt;中的一个&lt;strong&gt;必要环节&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实践常见的系统设计面试题&lt;/strong&gt;并且把你的答案和&lt;strong&gt;例子的解答&lt;/strong&gt;进行&lt;strong&gt;对照&lt;/strong&gt;：讨论，代码和图表。&lt;/p&gt;

&lt;p&gt;面试准备的其他主题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#学习指引&quot;&gt;学习指引&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#如何处理一个系统设计的面试题&quot;&gt;如何处理一个系统设计的面试题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#系统设计的面试题和解答&quot;&gt;系统设计的面试题，&lt;strong&gt;含解答&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#面向对象设计的面试问题及解答&quot;&gt;面向对象设计的面试题，&lt;strong&gt;含解答&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#其它的系统设计面试题&quot;&gt;其它的系统设计面试题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;系统设计主题的索引&quot;&gt;系统设计主题的索引&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;各种系统设计主题的摘要，包括优点和缺点。&lt;strong&gt;每一个主题都面临着取舍和权衡&lt;/strong&gt;。&lt;/p&gt;

  &lt;p&gt;每个章节都包含着更多的资源的链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/jrUBAF7.png&quot; /&gt;
  &lt;br /&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#系统设计主题从这里开始&quot;&gt;系统设计主题：从这里开始&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#第一步回顾可扩展性scalability的视频讲座&quot;&gt;第一步：回顾可扩展性的视频讲座&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#第二步回顾可扩展性文章&quot;&gt;第二步：回顾可扩展性的文章&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#接下来的步骤&quot;&gt;接下来的步骤&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#性能与可扩展性&quot;&gt;性能与拓展性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#延迟与吞吐量&quot;&gt;延迟与吞吐量&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#可用性与一致性&quot;&gt;可用性与一致性&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#cap-理论&quot;&gt;CAP 理论&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#cp--一致性和分区容错性&quot;&gt;CP - 一致性和分区容错性&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#ap--可用性与分区容错性&quot;&gt;AP - 可用性和分区容错性&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#一致性模式&quot;&gt;一致模式&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#弱一致性&quot;&gt;弱一致性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#最终一致性&quot;&gt;最终一致性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#强一致性&quot;&gt;强一致性&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#可用性模式&quot;&gt;可用模式&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#故障切换&quot;&gt;故障切换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#复制&quot;&gt;复制&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#域名系统&quot;&gt;域名系统&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#内容分发网络cdn&quot;&gt;CDN&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#cdn-推送push&quot;&gt;CDN 推送&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cdn-拉取pull&quot;&gt;CDN 拉取&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#负载均衡器&quot;&gt;负载均衡器&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#工作到备用切换active-passive&quot;&gt;工作到备用切换（Active-passive）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#双工作切换active-active&quot;&gt;双工作切换（Active-active）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#四层负载均衡&quot;&gt;四层负载均衡&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#七层负载均衡器&quot;&gt;七层负载均衡&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#水平扩展&quot;&gt;水平扩展&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#反向代理web-服务器&quot;&gt;反向代理（web 服务器）&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#负载均衡器与反向代理&quot;&gt;负载均衡与反向代理&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#应用层&quot;&gt;应用层&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#微服务&quot;&gt;微服务&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#服务发现&quot;&gt;服务发现&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#数据库&quot;&gt;数据库&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#关系型数据库管理系统rdbms&quot;&gt;关系型数据库管理系统（RDBMS）&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#主从复制&quot;&gt;Master-slave 复制集&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#主主复制&quot;&gt;Master-master 复制集&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#联合&quot;&gt;联合&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#分片&quot;&gt;分片&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#非规范化&quot;&gt;非规范化&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#sql-调优&quot;&gt;SQL 调优&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#nosql&quot;&gt;NoSQL&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#键-值存储&quot;&gt;Key-value 存储&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#文档类型存储&quot;&gt;文档存储&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#列型存储&quot;&gt;宽列存储&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#图数据库&quot;&gt;图数据库&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sql-还是-nosql&quot;&gt;SQL 还是 NoSQL&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#缓存&quot;&gt;缓存&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#客户端缓存&quot;&gt;客户端缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cdn-缓存&quot;&gt;CDN 缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#web-服务器缓存&quot;&gt;Web 服务器缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#数据库缓存&quot;&gt;数据库缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#应用缓存&quot;&gt;应用缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#数据库查询级别的缓存&quot;&gt;数据库查询级别的缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#对象级别的缓存&quot;&gt;对象级别的缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#何时更新缓存&quot;&gt;何时更新缓存&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#缓存模式&quot;&gt;缓存模式&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#直写模式&quot;&gt;直写模式&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#回写模式&quot;&gt;回写模式&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#刷新&quot;&gt;刷新&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#异步&quot;&gt;异步&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#消息队列&quot;&gt;消息队列&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#任务队列&quot;&gt;任务队列&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#背压&quot;&gt;背压机制&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#通讯&quot;&gt;通讯&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#传输控制协议tcp&quot;&gt;传输控制协议（TCP）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#用户数据报协议udp&quot;&gt;用户数据报协议（UDP）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#远程过程调用协议rpc&quot;&gt;远程控制调用协议（RPC）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#表述性状态转移rest&quot;&gt;表述性状态转移（REST）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#安全&quot;&gt;安全&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#附录&quot;&gt;附录&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#2-的次方表&quot;&gt;2 的次方表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#每个程序员都应该知道的延迟数&quot;&gt;每个程序员都应该知道的延迟数&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#其它的系统设计面试题&quot;&gt;其它的系统设计面试题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#真实架构&quot;&gt;真实架构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#公司的系统架构&quot;&gt;公司的系统架构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#公司工程博客&quot;&gt;公司工程博客&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#正在完善中&quot;&gt;正在完善中&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#致谢&quot;&gt;致谢&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#联系方式&quot;&gt;联系方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#许可&quot;&gt;许可&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;学习指引&quot;&gt;学习指引&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;基于你面试的时间线（短、中、长）去复习那些推荐的主题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/OfVllex.png&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：对于面试来说，我需要知道这里的所有知识点吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;答：不，如果只是为了准备面试的话，你并不需要知道所有的知识点。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在一场面试中你会被问到什么取决于下面这些因素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你的经验&lt;/li&gt;
  &lt;li&gt;你的技术背景&lt;/li&gt;
  &lt;li&gt;你面试的职位&lt;/li&gt;
  &lt;li&gt;你面试的公司&lt;/li&gt;
  &lt;li&gt;运气&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那些有经验的候选人通常会被期望了解更多的系统设计的知识。架构师或者团队负责人则会被期望了解更多除了个人贡献之外的知识。顶级的科技公司通常也会有一次或者更多的系统设计面试。&lt;/p&gt;

&lt;p&gt;面试会很宽泛的展开并在几个领域深入。这会帮助你了解一些关于系统设计的不同的主题。基于你的时间线，经验，面试的职位和面试的公司对下面的指导做出适当的调整。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;短期&lt;/strong&gt; - 以系统设计主题的&lt;strong&gt;广度&lt;/strong&gt;为目标。通过解决&lt;strong&gt;一些&lt;/strong&gt;面试题来练习。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;中期&lt;/strong&gt; - 以系统设计主题的&lt;strong&gt;广度&lt;/strong&gt;和&lt;strong&gt;初级深度&lt;/strong&gt;为目标。通过解决&lt;strong&gt;很多&lt;/strong&gt;面试题来练习。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;长期&lt;/strong&gt; - 以系统设计主题的&lt;strong&gt;广度&lt;/strong&gt;和&lt;strong&gt;高级深度&lt;/strong&gt;为目标。通过解决&lt;strong&gt;大部分&lt;/strong&gt;面试题来练习。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;短期&lt;/th&gt;
      &lt;th&gt;中期&lt;/th&gt;
      &lt;th&gt;长期&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;阅读 &lt;a href=&quot;#系统设计主题的索引&quot;&gt;系统设计主题&lt;/a&gt; 以获得一个关于系统如何工作的宽泛的认识&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;阅读一些你要面试的&lt;a href=&quot;#公司工程博客&quot;&gt;公司工程博客&lt;/a&gt;的文章&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;阅读 &lt;a href=&quot;#真实架构&quot;&gt;真实架构&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;复习 &lt;a href=&quot;#如何处理一个系统设计面试题&quot;&gt;如何处理一个系统设计面试题&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
      &lt;td&gt;:+1:&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成 &lt;a href=&quot;#系统设计的面试题和解答&quot;&gt;系统设计的面试题和解答&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一些&lt;/td&gt;
      &lt;td&gt;很多&lt;/td&gt;
      &lt;td&gt;大部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成 &lt;a href=&quot;#面向对象设计的面试问题及解答&quot;&gt;面向对象设计的面试题和解答&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一些&lt;/td&gt;
      &lt;td&gt;很多&lt;/td&gt;
      &lt;td&gt;大部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;复习 &lt;a href=&quot;#其它的系统设计面试题&quot;&gt;其它的系统设计面试题&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一些&lt;/td&gt;
      &lt;td&gt;很多&lt;/td&gt;
      &lt;td&gt;大部分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;如何处理一个系统设计的面试题&quot;&gt;如何处理一个系统设计的面试题&lt;/h2&gt;

&lt;p&gt;系统设计面试是一个&lt;strong&gt;开放式的对话&lt;/strong&gt;。他们期望你去主导这个对话。&lt;/p&gt;

&lt;p&gt;你可以使用下面的步骤来指引讨论。为了巩固这个过程，请使用下面的步骤完成&lt;a href=&quot;#系统设计的面试题和解答&quot;&gt;系统设计的面试题和解答&lt;/a&gt;这个章节。&lt;/p&gt;

&lt;h3 id=&quot;第一步描述使用场景约束和假设&quot;&gt;第一步：描述使用场景，约束和假设&lt;/h3&gt;

&lt;p&gt;把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;谁会使用它？&lt;/li&gt;
  &lt;li&gt;他们会怎样使用它？&lt;/li&gt;
  &lt;li&gt;有多少用户？&lt;/li&gt;
  &lt;li&gt;系统的作用是什么？&lt;/li&gt;
  &lt;li&gt;系统的输入输出分别是什么？&lt;/li&gt;
  &lt;li&gt;我们希望处理多少数据？&lt;/li&gt;
  &lt;li&gt;我们希望每秒钟处理多少请求？&lt;/li&gt;
  &lt;li&gt;我们希望的读写比率？&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第二步创造一个高层级的设计&quot;&gt;第二步：创造一个高层级的设计&lt;/h3&gt;

&lt;p&gt;使用所有重要的组件来描绘出一个高层级的设计。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;画出主要的组件和连接&lt;/li&gt;
  &lt;li&gt;证明你的想法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第三步设计核心组件&quot;&gt;第三步：设计核心组件&lt;/h3&gt;

&lt;p&gt;对每一个核心组件进行详细深入的分析。举例来说，如果你被问到&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/pastebin/README.md&quot;&gt;设计一个 url 缩写服务&lt;/a&gt;，开始讨论：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生成并储存一个完整 url 的 hash
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/pastebin/README.md&quot;&gt;MD5&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/pastebin/README.md&quot;&gt;Base62&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Hash 碰撞&lt;/li&gt;
      &lt;li&gt;SQL 还是 NoSQL&lt;/li&gt;
      &lt;li&gt;数据库模型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将一个 hashed url 翻译成完整的 url
    &lt;ul&gt;
      &lt;li&gt;数据库查找&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;API 和面向对象设计&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第四步扩展设计&quot;&gt;第四步：扩展设计&lt;/h3&gt;

&lt;p&gt;确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;负载均衡&lt;/li&gt;
  &lt;li&gt;水平扩展&lt;/li&gt;
  &lt;li&gt;缓存&lt;/li&gt;
  &lt;li&gt;数据库分片&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;论述可能的解决办法和代价。每件事情需要取舍。可以使用&lt;a href=&quot;#系统设计主题的索引&quot;&gt;可扩展系统的设计原则&lt;/a&gt;来处理瓶颈。&lt;/p&gt;

&lt;h3 id=&quot;预估计算量&quot;&gt;预估计算量&lt;/h3&gt;

&lt;p&gt;你或许会被要求通过手算进行一些估算。&lt;a href=&quot;#附录&quot;&gt;附录&lt;/a&gt;涉及到的是下面的这些资源：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html&quot;&gt;使用预估计算量&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-的次方表&quot;&gt;2 的次方表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#每个程序员都应该知道的延迟数&quot;&gt;每个程序员都应该知道的延迟数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;相关资源和延伸阅读&quot;&gt;相关资源和延伸阅读&lt;/h3&gt;

&lt;p&gt;查看下面的链接以获得我们期望的更好的想法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/&quot;&gt;怎样通过一个系统设计的面试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.hiredintech.com/system-design&quot;&gt;系统设计的面试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ZgdS0EUmn70&quot;&gt;系统架构与设计的面试简介&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;系统设计的面试题和解答&quot;&gt;系统设计的面试题和解答&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;普通的系统设计面试题和相关事例的论述，代码和图表。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;与内容有关的解答在 &lt;code&gt;solutions/&lt;/code&gt; 文件夹中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;问题&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;设计 Pastebin.com (或者 Bit.ly)&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/pastebin/README-zh-Hans.md&quot;&gt;解答&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计 Twitter 时间线和搜索 (或者 Facebook feed 和搜索)&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/twitter/README.md&quot;&gt;解答&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一个网页爬虫&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/web_crawler/README.md&quot;&gt;解答&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计 Mint.com&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/mint/README.md&quot;&gt;解答&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;为一个社交网络设计数据结构&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/social_graph/README.md&quot;&gt;解答&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;为搜索引擎设计一个 key-value 储存&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/query_cache/README.md&quot;&gt;解答&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;通过分类特性设计 Amazon 的销售排名&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/sales_rank/README.md&quot;&gt;解答&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;在 AWS 上设计一个百万用户级别的系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/scaling_aws/README.md&quot;&gt;解答&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;添加一个系统设计问题&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#贡献&quot;&gt;贡献&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;设计-pastebincom-或者-bitly&quot;&gt;设计 Pastebin.com (或者 Bit.ly)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/pastebin/README.md&quot;&gt;查看实践与解答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/4edXG0T.png&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;设计-twitter-时间线和搜索-或者-facebook-feed-和搜索&quot;&gt;设计 Twitter 时间线和搜索 (或者 Facebook feed 和搜索)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/twitter/README.md&quot;&gt;查看实践与解答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/jrUBAF7.png&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;设计一个网页爬虫&quot;&gt;设计一个网页爬虫&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/web_crawler/README.md&quot;&gt;查看实践与解答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/bWxPtQA.png&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;设计-mintcom&quot;&gt;设计 Mint.com&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/mint/README.md&quot;&gt;查看实践与解答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/V5q57vU.png&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;为一个社交网络设计数据结构&quot;&gt;为一个社交网络设计数据结构&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/social_graph/README.md&quot;&gt;查看实践与解答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/cdCv5g7.png&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;为搜索引擎设计一个-key-value-储存&quot;&gt;为搜索引擎设计一个 key-value 储存&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/query_cache/README.md&quot;&gt;查看实践与解答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/4j99mhe.png&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;设计按类别分类的-amazon-销售排名&quot;&gt;设计按类别分类的 Amazon 销售排名&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/sales_rank/README.md&quot;&gt;查看实践与解答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/MzExP06.png&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;在-aws-上设计一个百万用户级别的系统&quot;&gt;在 AWS 上设计一个百万用户级别的系统&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/scaling_aws/README.md&quot;&gt;查看实践与解答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2022/jj3A5N8.png&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;面向对象设计的面试问题及解答&quot;&gt;面向对象设计的面试问题及解答&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;常见面向对象设计面试问题及实例讨论，代码和图表演示。&lt;/p&gt;

  &lt;p&gt;与内容相关的解决方案在 &lt;code&gt;solutions/&lt;/code&gt; 文件夹中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注：此节还在完善中&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;问题&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;设计 hash map&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/object_oriented_design/hash_table/hash_map.ipynb&quot;&gt;解决方案&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计 LRU 缓存&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb&quot;&gt;解决方案&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一个呼叫中心&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/object_oriented_design/call_center/call_center.ipynb&quot;&gt;解决方案&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一副牌&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb&quot;&gt;解决方案&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一个停车场&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb&quot;&gt;解决方案&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一个聊天服务&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer/blob/master/solutions/object_oriented_design/online_chat/online_chat.ipynb&quot;&gt;解决方案&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一个环形数组&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#贡献&quot;&gt;待解决&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;添加一个面向对象设计问题&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#贡献&quot;&gt;待解决&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;系统设计主题从这里开始&quot;&gt;系统设计主题：从这里开始&lt;/h2&gt;

&lt;p&gt;不熟悉系统设计？&lt;/p&gt;

&lt;p&gt;首先，你需要对一般性原则有一个基本的认识，知道它们是什么，怎样使用以及利弊。&lt;/p&gt;

&lt;h3 id=&quot;第一步回顾可扩展性scalability的视频讲座&quot;&gt;第一步：回顾可扩展性（scalability）的视频讲座&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=-W9F__D3oY4&quot;&gt;哈佛大学可扩展性讲座&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主题涵盖
    &lt;ul&gt;
      &lt;li&gt;垂直扩展（Vertical scaling）&lt;/li&gt;
      &lt;li&gt;水平扩展（Horizontal scaling）&lt;/li&gt;
      &lt;li&gt;缓存&lt;/li&gt;
      &lt;li&gt;负载均衡&lt;/li&gt;
      &lt;li&gt;数据库复制&lt;/li&gt;
      &lt;li&gt;数据库分区&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第二步回顾可扩展性文章&quot;&gt;第二步：回顾可扩展性文章&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.lecloud.net/tagged/scalability/chrono&quot;&gt;可扩展性&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主题涵盖：
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones&quot;&gt;Clones&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database&quot;&gt;数据库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache&quot;&gt;缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism&quot;&gt;异步&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;接下来的步骤&quot;&gt;接下来的步骤&lt;/h3&gt;

&lt;p&gt;接下来，我们将看看高阶的权衡和取舍:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;性能&lt;/strong&gt;与&lt;strong&gt;可扩展性&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;延迟&lt;/strong&gt;与&lt;strong&gt;吞吐量&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可用性&lt;/strong&gt;与&lt;strong&gt;一致性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;记住&lt;strong&gt;每个方面都面临取舍和权衡&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;然后，我们将深入更具体的主题，如 DNS、CDN 和负载均衡器。&lt;/p&gt;

&lt;h2 id=&quot;性能与可扩展性&quot;&gt;性能与可扩展性&lt;/h2&gt;

&lt;p&gt;如果服务&lt;strong&gt;性能&lt;/strong&gt;的增长与资源的增加是成比例的，服务就是可扩展的。通常，提高性能意味着服务于更多的工作单元，另一方面，当数据集增长时，同样也可以处理更大的工作单位。&lt;sup&gt;&lt;a href=&quot;http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;另一个角度来看待性能与可扩展性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果你的系统有&lt;strong&gt;性能&lt;/strong&gt;问题，对于单个用户来说是缓慢的。&lt;/li&gt;
  &lt;li&gt;如果你的系统有&lt;strong&gt;可扩展性&lt;/strong&gt;问题，单个用户较快但在高负载下会变慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;来源及延伸阅读&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html&quot;&gt;简单谈谈可扩展性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/jboner/scalability-availability-stability-patterns/&quot;&gt;可扩展性，可用性，稳定性和模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;延迟与吞吐量&quot;&gt;延迟与吞吐量&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;延迟&lt;/strong&gt;是执行操作或运算结果所花费的时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;是单位时间内（执行）此类操作或运算的数量。&lt;/p&gt;

&lt;p&gt;通常，你应该以&lt;strong&gt;可接受级延迟&lt;/strong&gt;下&lt;strong&gt;最大化吞吐量&lt;/strong&gt;为目标。&lt;/p&gt;

&lt;h3 id=&quot;来源及延伸阅读-1&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://community.cadence.com/cadence_blogs_8/b/sd/archive/2010/09/13/understanding-latency-vs-throughput&quot;&gt;理解延迟与吞吐量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;可用性与一致性&quot;&gt;可用性与一致性&lt;/h2&gt;

&lt;h3 id=&quot;cap-理论&quot;&gt;CAP 理论&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/bgLMI2u.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://robertgreiner.com/2014/08/cap-theorem-revisited&quot;&gt;来源：再看 CAP 理论&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;在一个分布式计算系统中，只能同时满足下列的两点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt; ─ 每次访问都能获得最新数据但可能会收到错误响应&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可用性&lt;/strong&gt; ─ 每次访问都能收到非错响应，但不保证获取到最新数据&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分区容错性&lt;/strong&gt; ─ 在任意分区网络故障的情况下系统仍能继续运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;网络并不可靠，所以你应要支持分区容错性，并需要在软件可用性和一致性间做出取舍。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;cp--一致性和分区容错性&quot;&gt;CP ─ 一致性和分区容错性&lt;/h4&gt;

&lt;p&gt;等待分区节点的响应可能会导致延时错误。如果你的业务需求需要原子读写，CP 是一个不错的选择。&lt;/p&gt;

&lt;h4 id=&quot;ap--可用性与分区容错性&quot;&gt;AP ─ 可用性与分区容错性&lt;/h4&gt;

&lt;p&gt;响应节点上可用数据的最近版本可能并不是最新的。当分区解析完后，写入（操作）可能需要一些时间来传播。&lt;/p&gt;

&lt;p&gt;如果业务需求允许&lt;a href=&quot;#最终一致性&quot;&gt;最终一致性&lt;/a&gt;，或当有外部故障时要求系统继续运行，AP 是一个不错的选择。&lt;/p&gt;

&lt;h3 id=&quot;来源及延伸阅读-2&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://robertgreiner.com/2014/08/cap-theorem-revisited/&quot;&gt;再看 CAP 理论&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ksat.me/a-plain-english-introduction-to-cap-theorem/&quot;&gt;通俗易懂地介绍 CAP 理论&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/henryr/cap-faq&quot;&gt;CAP FAQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;一致性模式&quot;&gt;一致性模式&lt;/h2&gt;

&lt;p&gt;有同一份数据的多份副本，我们面临着怎样同步它们的选择，以便让客户端有一致的显示数据。回想 &lt;a href=&quot;#cap-理论&quot;&gt;CAP 理论&lt;/a&gt;中的一致性定义 ─ 每次访问都能获得最新数据但可能会收到错误响应&lt;/p&gt;

&lt;h3 id=&quot;弱一致性&quot;&gt;弱一致性&lt;/h3&gt;

&lt;p&gt;在写入之后，访问可能看到，也可能看不到（写入数据）。尽力优化之让其能访问最新数据。&lt;/p&gt;

&lt;p&gt;这种方式可以 memcached 等系统中看到。弱一致性在 VoIP，视频聊天和实时多人游戏等真实用例中表现不错。打个比方，如果你在通话中丢失信号几秒钟时间，当重新连接时你是听不到这几秒钟所说的话的。&lt;/p&gt;

&lt;h3 id=&quot;最终一致性&quot;&gt;最终一致性&lt;/h3&gt;

&lt;p&gt;在写入后，访问最终能看到写入数据（通常在数毫秒内）。数据被异步复制。&lt;/p&gt;

&lt;p&gt;DNS 和 email 等系统使用的是此种方式。最终一致性在高可用性系统中效果不错。&lt;/p&gt;

&lt;h3 id=&quot;强一致性&quot;&gt;强一致性&lt;/h3&gt;

&lt;p&gt;在写入后，访问立即可见。数据被同步复制。&lt;/p&gt;

&lt;p&gt;文件系统和关系型数据库（RDBMS）中使用的是此种方式。强一致性在需要记录的系统中运作良好。&lt;/p&gt;

&lt;h3 id=&quot;来源及延伸阅读-3&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://snarfed.org/transactions_across_datacenters_io.html&quot;&gt;Transactions across data centers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;可用性模式&quot;&gt;可用性模式&lt;/h2&gt;

&lt;p&gt;有两种支持高可用性的模式: &lt;strong&gt;故障切换（fail-over）&lt;/strong&gt;和&lt;strong&gt;复制（replication）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;故障切换&quot;&gt;故障切换&lt;/h3&gt;

&lt;h4 id=&quot;工作到备用切换active-passive&quot;&gt;工作到备用切换（Active-passive）&lt;/h4&gt;

&lt;p&gt;关于工作到备用的故障切换流程是，工作服务器发送周期信号给待机中的备用服务器。如果周期信号中断，备用服务器切换成工作服务器的 IP 地址并恢复服务。&lt;/p&gt;

&lt;p&gt;宕机时间取决于备用服务器处于“热”待机状态还是需要从“冷”待机状态进行启动。只有工作服务器处理流量。&lt;/p&gt;

&lt;p&gt;工作到备用的故障切换也被称为主从切换。&lt;/p&gt;

&lt;h4 id=&quot;双工作切换active-active&quot;&gt;双工作切换（Active-active）&lt;/h4&gt;

&lt;p&gt;在双工作切换中，双方都在管控流量，在它们之间分散负载。&lt;/p&gt;

&lt;p&gt;如果是外网服务器，DNS 将需要对两方都了解。如果是内网服务器，应用程序逻辑将需要对两方都了解。&lt;/p&gt;

&lt;p&gt;双工作切换也可以称为主主切换。&lt;/p&gt;

&lt;h3 id=&quot;缺陷故障切换&quot;&gt;缺陷：故障切换&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;故障切换需要添加额外硬件并增加复杂性。&lt;/li&gt;
  &lt;li&gt;如果新写入数据在能被复制到备用系统之前，工作系统出现了故障，则有可能会丢失数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;复制&quot;&gt;复制&lt;/h3&gt;

&lt;h4 id=&quot;主从复制和主主复制&quot;&gt;主─从复制和主─主复制&lt;/h4&gt;

&lt;p&gt;这个主题进一步探讨了&lt;a href=&quot;#数据库&quot;&gt;数据库&lt;/a&gt;部分:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#主从复制&quot;&gt;主─从复制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#主主复制&quot;&gt;主─主复制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;域名系统&quot;&gt;域名系统&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/IOyLj4i.jpg&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.slideshare.net/srikrupa5/dns-security-presentation-issa&quot;&gt;来源：DNS 安全介绍&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;域名系统是把 www.example.com 等域名转换成 IP 地址。&lt;/p&gt;

&lt;p&gt;域名系统是分层次的，一些 DNS 服务器位于顶层。当查询（域名） IP 时，路由或 ISP 提供连接 DNS 服务器的信息。较底层的 DNS 服务器缓存映射，它可能会因为 DNS 传播延时而失效。DNS 结果可以缓存在浏览器或操作系统中一段时间，时间长短取决于&lt;a href=&quot;https://en.wikipedia.org/wiki/Time_to_live&quot;&gt;存活时间 TTL&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NS 记录（域名服务）&lt;/strong&gt; ─ 指定解析域名或子域名的 DNS 服务器。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MX 记录（邮件交换）&lt;/strong&gt; ─ 指定接收信息的邮件服务器。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A 记录（地址）&lt;/strong&gt; ─ 指定域名对应的 IP 地址记录。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CNAME（规范）&lt;/strong&gt; ─ 一个域名映射到另一个域名或 &lt;code&gt;CNAME&lt;/code&gt; 记录（ example.com 指向 www.example.com ）或映射到一个 &lt;code&gt;A&lt;/code&gt; 记录。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cloudflare.com/dns/&quot;&gt;CloudFlare&lt;/a&gt; 和 &lt;a href=&quot;https://aws.amazon.com/route53/&quot;&gt;Route 53&lt;/a&gt; 等平台提供管理 DNS 的功能。某些 DNS 服务通过集中方式来路由流量:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://g33kinfo.com/info/archives/2657&quot;&gt;加权轮询调度&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;防止流量进入维护中的服务器&lt;/li&gt;
      &lt;li&gt;在不同大小集群间负载均衡&lt;/li&gt;
      &lt;li&gt;A/B 测试&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基于延迟路由&lt;/li&gt;
  &lt;li&gt;基于地理位置路由&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;缺陷dns&quot;&gt;缺陷:DNS&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟。&lt;/li&gt;
  &lt;li&gt;虽然它们通常由&lt;a href=&quot;http://superuser.com/questions/472695/who-controls-the-dns-servers/472729&quot;&gt;政府，网络服务提供商和大公司&lt;/a&gt;管理，但 DNS 服务管理仍可能是复杂的。&lt;/li&gt;
  &lt;li&gt;DNS 服务最近遭受 &lt;a href=&quot;http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/&quot;&gt;DDoS 攻击&lt;/a&gt;，阻止不知道 Twitter IP 地址的用户访问 Twitter。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;来源及延伸阅读-4&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx&quot;&gt;DNS 架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_Name_System&quot;&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://support.dnsimple.com/categories/dns/&quot;&gt;关于 DNS 的文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;内容分发网络cdn&quot;&gt;内容分发网络（CDN）&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/h9TAuGI.jpg&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/&quot;&gt;来源：为什么使用 CDN&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，虽然亚马逊 CloudFront 等也支持动态内容。CDN 的 DNS 解析会告知客户端连接哪台服务器。&lt;/p&gt;

&lt;p&gt;将内容存储在 CDN 上可以从两个方面来提供性能:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从靠近用户的数据中心提供资源&lt;/li&gt;
  &lt;li&gt;通过 CDN 你的服务器不必真的处理请求&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cdn-推送push&quot;&gt;CDN 推送（push）&lt;/h3&gt;

&lt;p&gt;当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。&lt;/p&gt;

&lt;h3 id=&quot;cdn-拉取pull&quot;&gt;CDN 拉取（pull）&lt;/h3&gt;

&lt;p&gt;CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Time_to_live&quot;&gt;存活时间（TTL）&lt;/a&gt;决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。&lt;/p&gt;

&lt;p&gt;高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。&lt;/p&gt;

&lt;h3 id=&quot;缺陷cdn&quot;&gt;缺陷：CDN&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。&lt;/li&gt;
  &lt;li&gt;如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。&lt;/li&gt;
  &lt;li&gt;CDN 需要更改静态内容的 URL 地址以指向 CDN。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;来源及延伸阅读-5&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;amp;context=compsci&quot;&gt;全球性内容分发网络&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/&quot;&gt;CDN 拉取和 CDN 推送的区别&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;负载均衡器&quot;&gt;负载均衡器&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/h81n9iK.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html&quot;&gt;来源：可扩展的系统设计模式&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;防止请求进入不好的服务器&lt;/li&gt;
  &lt;li&gt;防止资源过载&lt;/li&gt;
  &lt;li&gt;帮助消除单一的故障点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;负载均衡器可以通过硬件（昂贵）或 HAProxy 等软件来实现。
增加的好处包括:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SSL 终结&lt;/strong&gt; ─ 解密传入的请求并加密服务器响应，这样的话后端服务器就不必再执行这些潜在高消耗运算了。
    &lt;ul&gt;
      &lt;li&gt;不需要再每台服务器上安装 &lt;a href=&quot;https://en.wikipedia.org/wiki/X.509&quot;&gt;X.509 证书&lt;/a&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Session 留存&lt;/strong&gt; ─ 如果 Web 应用程序不追踪会话，发出 cookie 并将特定客户端的请求路由到同一实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常会设置采用&lt;a href=&quot;#工作到备用切换active-passive&quot;&gt;工作─备用&lt;/a&gt; 或 &lt;a href=&quot;#双工作切换active-active&quot;&gt;双工作&lt;/a&gt; 模式的多个负载均衡器，以免发生故障。&lt;/p&gt;

&lt;p&gt;负载均衡器能基于多种方式来路由流量:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;随机&lt;/li&gt;
  &lt;li&gt;最少负载&lt;/li&gt;
  &lt;li&gt;Session/cookie&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://g33kinfo.com/info/archives/2657&quot;&gt;轮询调度或加权轮询调度算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#四层负载均衡&quot;&gt;四层负载均衡&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#七层负载均衡&quot;&gt;七层负载均衡&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;四层负载均衡&quot;&gt;四层负载均衡&lt;/h3&gt;

&lt;p&gt;四层负载均衡根据监看&lt;a href=&quot;#通讯&quot;&gt;传输层&lt;/a&gt;的信息来决定如何分发请求。通常，这会涉及来源，目标 IP 地址和请求头中的端口，但不包括数据包（报文）内容。四层负载均衡执行&lt;a href=&quot;https://www.nginx.com/resources/glossary/layer-4-load-balancing/&quot;&gt;网络地址转换（NAT）&lt;/a&gt;来向上游服务器转发网络数据包。&lt;/p&gt;

&lt;h3 id=&quot;七层负载均衡器&quot;&gt;七层负载均衡器&lt;/h3&gt;

&lt;p&gt;七层负载均衡器根据监控&lt;a href=&quot;#通讯&quot;&gt;应用层&lt;/a&gt;来决定怎样分发请求。这会涉及请求头的内容，消息和 cookie。七层负载均衡器终结网络流量，读取消息，做出负载均衡判定，然后传送给特定服务器。比如，一个七层负载均衡器能直接将视频流量连接到托管视频的服务器，同时将更敏感的用户账单流量引导到安全性更强的服务器。&lt;/p&gt;

&lt;p&gt;以损失灵活性为代价，四层负载均衡比七层负载均衡花费更少时间和计算资源，虽然这对现代商用硬件的性能影响甚微。&lt;/p&gt;

&lt;h3 id=&quot;水平扩展&quot;&gt;水平扩展&lt;/h3&gt;

&lt;p&gt;负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上&lt;strong&gt;垂直扩展&lt;/strong&gt;更贵的硬件具有更高的可用性。相比招聘特定企业系统人才，招聘商业硬件方面的人才更加容易。&lt;/p&gt;

&lt;h4 id=&quot;缺陷水平扩展&quot;&gt;缺陷：水平扩展&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;水平扩展引入了复杂度并涉及服务器复制
    &lt;ul&gt;
      &lt;li&gt;服务器应该是无状态的:它们也不该包含像 session 或资料图片等与用户关联的数据。&lt;/li&gt;
      &lt;li&gt;session 可以集中存储在数据库或持久化&lt;a href=&quot;#缓存&quot;&gt;缓存&lt;/a&gt;（Redis、Memcached）的数据存储区中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;缺陷负载均衡器&quot;&gt;缺陷：负载均衡器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。&lt;/li&gt;
  &lt;li&gt;引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。&lt;/li&gt;
  &lt;li&gt;单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;来源及延伸阅读-6&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/&quot;&gt;NGINX 架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.haproxy.org/download/1.2/doc/architecture.txt&quot;&gt;HAProxy 架构指南&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones&quot;&gt;可扩展性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Load_balancing_(computing)&quot;&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.nginx.com/resources/glossary/layer-4-load-balancing/&quot;&gt;四层负载平衡&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.nginx.com/resources/glossary/layer-7-load-balancing/&quot;&gt;七层负载平衡&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html&quot;&gt;ELB 监听器配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;反向代理web-服务器&quot;&gt;反向代理（web 服务器）&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/n41Azff.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg&quot;&gt;资料来源：维基百科&lt;/a&gt;&lt;/strong&gt;
  &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。&lt;/p&gt;

&lt;p&gt;带来的好处包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;增加安全性&lt;/strong&gt; - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;提高可扩展性和灵活性&lt;/strong&gt; - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地终结 SSL 会话&lt;/strong&gt; - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。
    &lt;ul&gt;
      &lt;li&gt;免除了在每个服务器上安装 &lt;a href=&quot;https://en.wikipedia.org/wiki/X.509&quot;&gt;X.509&lt;/a&gt; 证书的需要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;压缩&lt;/strong&gt; - 压缩服务器响应&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缓存&lt;/strong&gt; - 直接返回命中的缓存结果&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;静态内容&lt;/strong&gt; - 直接提供静态内容
    &lt;ul&gt;
      &lt;li&gt;HTML/CSS/JS&lt;/li&gt;
      &lt;li&gt;图片&lt;/li&gt;
      &lt;li&gt;视频&lt;/li&gt;
      &lt;li&gt;等等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;负载均衡器与反向代理&quot;&gt;负载均衡器与反向代理&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;当你有多个服务器时，部署负载均衡器非常有用。通常，负载均衡器将流量路由给一组功能相同的服务器上。&lt;/li&gt;
  &lt;li&gt;即使只有一台 web 服务器或者应用服务器时，反向代理也有用，可以参考上一节介绍的好处。&lt;/li&gt;
  &lt;li&gt;NGINX 和 HAProxy 等解决方案可以同时支持第七层反向代理和负载均衡。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不利之处反向代理&quot;&gt;不利之处：反向代理&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;引入反向代理会增加系统的复杂度。&lt;/li&gt;
  &lt;li&gt;单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如&lt;a href=&quot;https://en.wikipedia.org/wiki/Failover&quot;&gt;故障转移&lt;/a&gt;）会进一步增加复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;来源及延伸阅读-7&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/&quot;&gt;反向代理与负载均衡&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/&quot;&gt;NGINX 架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.haproxy.org/download/1.2/doc/architecture.txt&quot;&gt;HAProxy 架构指南&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reverse_proxy&quot;&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;应用层&quot;&gt;应用层&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/yB5SYwm.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer&quot;&gt;资料来源：可缩放系统构架介绍&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单一职责原则&lt;/strong&gt;提倡小型的，自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。&lt;/p&gt;

&lt;p&gt;应用层中的工作进程也有可以实现&lt;a href=&quot;#异步&quot;&gt;异步化&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;微服务&quot;&gt;微服务&lt;/h3&gt;

&lt;p&gt;与此讨论相关的话题是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Microservices&quot;&gt;微服务&lt;/a&gt;，可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。&lt;sup&gt;&amp;lt;a href=https://smartbear.com/learn/api-design/what-are-microservices&amp;gt;1&amp;lt;/a&amp;gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。&lt;/p&gt;

&lt;h3 id=&quot;服务发现&quot;&gt;服务发现&lt;/h3&gt;

&lt;p&gt;像 &lt;a href=&quot;https://www.consul.io/docs/index.html&quot;&gt;Consul&lt;/a&gt;，&lt;a href=&quot;https://coreos.com/etcd/docs/latest&quot;&gt;Etcd&lt;/a&gt; 和 &lt;a href=&quot;http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper&quot;&gt;Zookeeper&lt;/a&gt; 这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。&lt;a href=&quot;https://www.consul.io/intro/getting-started/checks.html&quot;&gt;Health checks&lt;/a&gt; 可以帮助确认服务的完整性和是否经常使用一个 &lt;a href=&quot;#超文本传输协议http&quot;&gt;HTTP&lt;/a&gt; 路径。Consul 和 Etcd 都有一个内建的 &lt;a href=&quot;#键-值存储&quot;&gt;key-value 存储&lt;/a&gt; 用来存储配置信息和其他的共享信息。&lt;/p&gt;

&lt;h3 id=&quot;不利之处应用层&quot;&gt;不利之处：应用层&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;添加由多个松耦合服务组成的应用层，从架构、运营、流程等层面来讲将非常不同（相对于单体系统）。&lt;/li&gt;
  &lt;li&gt;微服务会增加部署和运营的复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;来源及延伸阅读-8&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://lethain.com/introduction-to-architecting-systems-for-scale&quot;&gt;可缩放系统构架介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview&quot;&gt;破解系统设计面试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Service-oriented_architecture&quot;&gt;面向服务架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper&quot;&gt;Zookeeper 介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/&quot;&gt;构建微服务，你所需要知道的一切&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库&quot;&gt;数据库&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/Xkm5CXz.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=w95murBkYmU&quot;&gt;资料来源：扩展你的用户数到第一个一千万&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;h3 id=&quot;关系型数据库管理系统rdbms&quot;&gt;关系型数据库管理系统（RDBMS）&lt;/h3&gt;

&lt;p&gt;像 SQL 这样的关系型数据库是一系列以表的形式组织的数据项集合。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;校对注：这里作者 SQL 可能指的是 MySQL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;ACID&lt;/strong&gt; 用来描述关系型数据库&lt;a href=&quot;https://en.wikipedia.org/wiki/Database_transaction&quot;&gt;事务&lt;/a&gt;的特性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt; - 每个事务内部所有操作要么全部完成，要么全部不完成。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt; - 任何事务都使数据库从一个有效的状态转换到另一个有效状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;隔离性&lt;/strong&gt; - 并发执行事务的结果与顺序执行事务的结果相同。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;持久性&lt;/strong&gt; - 事务提交后，对系统的影响是永久的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关系型数据库扩展包括许多技术：&lt;strong&gt;主从复制&lt;/strong&gt;、&lt;strong&gt;主主复制&lt;/strong&gt;、&lt;strong&gt;联合&lt;/strong&gt;、&lt;strong&gt;分片&lt;/strong&gt;、&lt;strong&gt;非规范化&lt;/strong&gt;和 &lt;strong&gt;SQL调优&lt;/strong&gt;。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/C9ioGtn.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.slideshare.net/jboner/scalability-availability-stability-patterns/&quot;&gt;资料来源：可扩展性、可用性、稳定性、模式&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;h4 id=&quot;主从复制&quot;&gt;主从复制&lt;/h4&gt;

&lt;p&gt;主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。&lt;/p&gt;

&lt;h5 id=&quot;不利之处主从复制&quot;&gt;不利之处：主从复制&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;将从库提升为主库需要额外的逻辑。&lt;/li&gt;
  &lt;li&gt;参考&lt;a href=&quot;#不利之处复制&quot;&gt;不利之处：复制&lt;/a&gt;中，主从复制和主主复制&lt;strong&gt;共同&lt;/strong&gt;的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/krAHLGg.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.slideshare.net/jboner/scalability-availability-stability-patterns/&quot;&gt;资料来源：可扩展性、可用性、稳定性、模式&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;h4 id=&quot;主主复制&quot;&gt;主主复制&lt;/h4&gt;

&lt;p&gt;两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。&lt;/p&gt;

&lt;h5 id=&quot;不利之处-主主复制&quot;&gt;不利之处： 主主复制&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;你需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。&lt;/li&gt;
  &lt;li&gt;多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。&lt;/li&gt;
  &lt;li&gt;随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。&lt;/li&gt;
  &lt;li&gt;参考&lt;a href=&quot;#不利之处复制&quot;&gt;不利之处：复制&lt;/a&gt;中，主从复制和主主复制&lt;strong&gt;共同&lt;/strong&gt;的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;不利之处复制&quot;&gt;不利之处：复制&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能。&lt;/li&gt;
  &lt;li&gt;写入会被重放到负责读取操作的副本。副本可能因为过多写操作阻塞住，导致读取功能异常。&lt;/li&gt;
  &lt;li&gt;读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟。&lt;/li&gt;
  &lt;li&gt;在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但读取副本只支持单线程顺序地写入。&lt;/li&gt;
  &lt;li&gt;复制意味着更多的硬件和额外的复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;来源及延伸阅读-9&quot;&gt;来源及延伸阅读&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/jboner/scalability-availability-stability-patterns/&quot;&gt;扩展性，可用性，稳定性模式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multi-master_replication&quot;&gt;多主复制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;联合&quot;&gt;联合&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/U3qV33e.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=w95murBkYmU&quot;&gt;资料来源：扩展你的用户数到第一个一千万&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：&lt;strong&gt;论坛&lt;/strong&gt;、&lt;strong&gt;用户&lt;/strong&gt;和&lt;strong&gt;产品&lt;/strong&gt;，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。&lt;/p&gt;

&lt;h5 id=&quot;不利之处联合&quot;&gt;不利之处：联合&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;如果你的数据库模式需要大量的功能和数据表，联合的效率并不好。&lt;/li&gt;
  &lt;li&gt;你需要更新应用程序的逻辑来确定要读取和写入哪个数据库。&lt;/li&gt;
  &lt;li&gt;用 &lt;a href=&quot;http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers&quot;&gt;server link&lt;/a&gt; 从两个库联结数据更复杂。&lt;/li&gt;
  &lt;li&gt;联合需要更多的硬件和额外的复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;来源及延伸阅读联合&quot;&gt;来源及延伸阅读：联合&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=w95murBkYmU&quot;&gt;扩展你的用户数到第一个一千万&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分片&quot;&gt;分片&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/wU8x5Id.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.slideshare.net/jboner/scalability-availability-stability-patterns/&quot;&gt;资料来源：可扩展性、可用性、稳定性、模式&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。&lt;/p&gt;

&lt;p&gt;类似&lt;a href=&quot;#联合&quot;&gt;联合&lt;/a&gt;的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。&lt;/p&gt;

&lt;p&gt;常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。&lt;/p&gt;

&lt;h5 id=&quot;不利之处分片&quot;&gt;不利之处：分片&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。&lt;/li&gt;
  &lt;li&gt;分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。
    &lt;ul&gt;
      &lt;li&gt;再平衡会引入额外的复杂度。基于&lt;a href=&quot;http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html&quot;&gt;一致性哈希&lt;/a&gt;的分片算法可以减少这种情况。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;联结多个分片的数据操作更复杂。&lt;/li&gt;
  &lt;li&gt;分片需要更多的硬件和额外的复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;来源及延伸阅读分片&quot;&gt;来源及延伸阅读：分片&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html&quot;&gt;分片时代来临&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shard_(database_architecture)&quot;&gt;数据库分片架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html&quot;&gt;一致性哈希&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;非规范化&quot;&gt;非规范化&lt;/h4&gt;

&lt;p&gt;非规范化试图以写入性能为代价来换取读取性能。在多个表中冗余数据副本，以避免高成本的联结操作。一些关系型数据库，比如 &lt;a href=&quot;https://en.wikipedia.org/wiki/PostgreSQL&quot;&gt;PostgreSQL&lt;/a&gt; 和 Oracle 支持&lt;a href=&quot;https://en.wikipedia.org/wiki/Materialized_view&quot;&gt;物化视图&lt;/a&gt;，可以处理冗余信息存储和保证冗余副本一致。&lt;/p&gt;

&lt;p&gt;当数据使用诸如&lt;a href=&quot;#联合&quot;&gt;联合&lt;/a&gt;和&lt;a href=&quot;#分片&quot;&gt;分片&lt;/a&gt;等技术被分割，进一步提高了处理跨数据中心的联结操作复杂度。非规范化可以规避这种复杂的联结操作。&lt;/p&gt;

&lt;p&gt;在多数系统中，读取操作的频率远高于写入操作，比例可达到 100:1，甚至 1000:1。需要复杂的数据库联结的读取操作成本非常高，在磁盘操作上消耗了大量时间。&lt;/p&gt;

&lt;h5 id=&quot;不利之处非规范化&quot;&gt;不利之处：非规范化&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;数据会冗余。&lt;/li&gt;
  &lt;li&gt;约束可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度。&lt;/li&gt;
  &lt;li&gt;非规范化的数据库在高写入负载下性能可能比规范化的数据库差。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;来源及延伸阅读非规范化&quot;&gt;来源及延伸阅读：非规范化&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Denormalization&quot;&gt;非规范化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sql-调优&quot;&gt;SQL 调优&lt;/h4&gt;

&lt;p&gt;SQL 调优是一个范围很广的话题，有很多相关的&lt;a href=&quot;https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&amp;amp;field-keywords=sql+tuning&quot;&gt;书&lt;/a&gt;可以作为参考。&lt;/p&gt;

&lt;p&gt;利用&lt;strong&gt;基准测试&lt;/strong&gt;和&lt;strong&gt;性能分析&lt;/strong&gt;来模拟和发现系统瓶颈很重要。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;基准测试&lt;/strong&gt; - 用 &lt;a href=&quot;http://httpd.apache.org/docs/2.2/programs/ab.html&quot;&gt;ab&lt;/a&gt; 等工具模拟高负载情况。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;性能分析&lt;/strong&gt; - 通过启用如&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html&quot;&gt;慢查询日志&lt;/a&gt;等工具来辅助追踪性能问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基准测试和性能分析可能会指引你到以下优化方案。&lt;/p&gt;

&lt;h5 id=&quot;改进模式&quot;&gt;改进模式&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;CHAR&lt;/code&gt; 类型存储固定长度的字段，不要用 &lt;code&gt;VARCHAR&lt;/code&gt;。
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;CHAR&lt;/code&gt; 在快速、随机访问时效率很高。如果使用 &lt;code&gt;VARCHAR&lt;/code&gt;，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;TEXT&lt;/code&gt; 类型存储大块的文本，例如博客正文。&lt;code&gt;TEXT&lt;/code&gt; 还允许布尔搜索。使用 &lt;code&gt;TEXT&lt;/code&gt; 字段需要在磁盘上存储一个用于定位文本块的指针。&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;INT&lt;/code&gt; 类型存储高达 2^32 或 40 亿的较大数字。&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;DECIMAL&lt;/code&gt; 类型存储货币可以避免浮点数表示错误。&lt;/li&gt;
  &lt;li&gt;避免使用 &lt;code&gt;BLOBS&lt;/code&gt; 存储实际对象，而是用来存储存放对象的位置。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;VARCHAR(255)&lt;/code&gt; 是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。&lt;/li&gt;
  &lt;li&gt;在适用场景中设置 &lt;code&gt;NOT NULL&lt;/code&gt; 约束来&lt;a href=&quot;http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search&quot;&gt;提高搜索性能&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;使用正确的索引&quot;&gt;使用正确的索引&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;你正查询（&lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;GROUP BY&lt;/code&gt;、&lt;code&gt;ORDER BY&lt;/code&gt;、&lt;code&gt;JOIN&lt;/code&gt;）的列如果用了索引会更快。&lt;/li&gt;
  &lt;li&gt;索引通常表示为自平衡的 &lt;a href=&quot;https://en.wikipedia.org/wiki/B-tree&quot;&gt;B 树&lt;/a&gt;，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。&lt;/li&gt;
  &lt;li&gt;设置索引，会将数据存在内存中，占用了更多内存空间。&lt;/li&gt;
  &lt;li&gt;写入操作会变慢，因为索引需要被更新。&lt;/li&gt;
  &lt;li&gt;加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;避免高成本的联结操作&quot;&gt;避免高成本的联结操作&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;有性能需要，可以进行非规范化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;分割数据表&quot;&gt;分割数据表&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;将热点数据拆分到单独的数据表中，可以有助于缓存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;调优查询缓存&quot;&gt;调优查询缓存&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;在某些情况下，&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/query-cache&quot;&gt;查询缓存&lt;/a&gt;可能会导致&lt;a href=&quot;https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/&quot;&gt;性能问题&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;来源及延伸阅读-10&quot;&gt;来源及延伸阅读&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://20bits.com/article/10-tips-for-optimizing-mysql-queries-that-dont-suck&quot;&gt;MySQL 查询优化小贴士&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l&quot;&gt;为什么 VARCHAR(255) 很常见？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search&quot;&gt;Null 值是如何影响数据库性能的？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html&quot;&gt;慢查询日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nosql&quot;&gt;NoSQL&lt;/h3&gt;

&lt;p&gt;NoSQL 是&lt;strong&gt;键-值数据库&lt;/strong&gt;、&lt;strong&gt;文档型数据库&lt;/strong&gt;、&lt;strong&gt;列型数据库&lt;/strong&gt;或&lt;strong&gt;图数据库&lt;/strong&gt;的统称。数据库是非规范化的，表联结大多在应用程序代码中完成。大多数 NoSQL 无法实现真正符合 ACID 的事务，支持&lt;a href=&quot;#最终一致性&quot;&gt;最终一致&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BASE&lt;/strong&gt; 通常被用于描述 NoSQL 数据库的特性。相比 &lt;a href=&quot;#cap-理论&quot;&gt;CAP 理论&lt;/a&gt;，BASE 强调可用性超过一致性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;基本可用&lt;/strong&gt; - 系统保证可用性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;软状态&lt;/strong&gt; - 即使没有输入，系统状态也可能随着时间变化。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最终一致性&lt;/strong&gt; - 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了在 &lt;a href=&quot;#sql-还是-nosql&quot;&gt;SQL 还是 NoSQL&lt;/a&gt; 之间做选择，了解哪种类型的 NoSQL 数据库最适合你的用例也是非常有帮助的。我们将在下一节中快速了解下 &lt;strong&gt;键-值存储&lt;/strong&gt;、&lt;strong&gt;文档型存储&lt;/strong&gt;、&lt;strong&gt;列型存储&lt;/strong&gt;和&lt;strong&gt;图存储&lt;/strong&gt;数据库。&lt;/p&gt;

&lt;h4 id=&quot;键-值存储&quot;&gt;键-值存储&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;抽象模型：哈希表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;键-值存储通常可以实现 O(1) 时间读写，用内存或 SSD 存储数据。数据存储可以按&lt;a href=&quot;https://en.wikipedia.org/wiki/Lexicographical_order&quot;&gt;字典顺序&lt;/a&gt;维护键，从而实现键的高效检索。键-值存储可以用于存储元数据。&lt;/p&gt;

&lt;p&gt;键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如存放在内存中的缓存。键-值存储提供的操作有限，如果需要更多操作，复杂度将转嫁到应用程序层面。&lt;/p&gt;

&lt;p&gt;键-值存储是如文档存储，在某些情况下，甚至是图存储等更复杂的存储系统的基础。&lt;/p&gt;

&lt;h4 id=&quot;来源及延伸阅读-11&quot;&gt;来源及延伸阅读&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Key-value_database&quot;&gt;键-值数据库&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or&quot;&gt;键-值存储的劣势&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://qnimate.com/overview-of-redis-architecture/&quot;&gt;Redis 架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://adayinthelifeof.nl/2011/02/06/memcache-internals/&quot;&gt;Memcached 架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;文档类型存储&quot;&gt;文档类型存储&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;抽象模型：将文档作为值的键-值存储&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文档类型存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构提供 API 或查询语句来实现查询。请注意，许多键-值存储数据库有用值存储元数据的特性，这也模糊了这两种存储类型的界限。&lt;/p&gt;

&lt;p&gt;基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。&lt;/p&gt;

&lt;p&gt;MongoDB 和 CouchDB 等一些文档类型存储还提供了类似 SQL 语言的查询语句来实现复杂查询。DynamoDB 同时支持键-值存储和文档类型存储。&lt;/p&gt;

&lt;p&gt;文档类型存储具备高度的灵活性，常用于处理偶尔变化的数据。&lt;/p&gt;

&lt;h4 id=&quot;来源及延伸阅读文档类型存储&quot;&gt;来源及延伸阅读：文档类型存储&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Document-oriented_database&quot;&gt;面向文档的数据库&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mongodb.com/mongodb-architecture&quot;&gt;MongoDB 架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/&quot;&gt;CouchDB 架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up&quot;&gt;Elasticsearch 架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;列型存储&quot;&gt;列型存储&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/n16iOGk.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html&quot;&gt;资料来源: SQL 和 NoSQL，一个简短的历史&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;抽象模型：嵌套的 &lt;code&gt;ColumnFamily&amp;lt;RowKey, Columns&amp;lt;ColKey, Value, Timestamp&amp;gt;&amp;gt;&lt;/code&gt; 映射&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。&lt;/p&gt;

&lt;p&gt;Google 发布了第一个列型存储数据库 &lt;a href=&quot;http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf&quot;&gt;Bigtable&lt;/a&gt;，它影响了 Hadoop 生态系统中活跃的开源数据库 &lt;a href=&quot;https://www.mapr.com/blog/in-depth-look-hbase-architecture&quot;&gt;HBase&lt;/a&gt; 和 Facebook 的 &lt;a href=&quot;http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html&quot;&gt;Cassandra&lt;/a&gt;。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。&lt;/p&gt;

&lt;p&gt;列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。&lt;/p&gt;

&lt;h5 id=&quot;来源及延伸阅读列型存储&quot;&gt;来源及延伸阅读：列型存储&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html&quot;&gt;SQL 与 NoSQL 简史&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf&quot;&gt;BigTable 架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mapr.com/blog/in-depth-look-hbase-architecture&quot;&gt;Hbase 架构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html&quot;&gt;Cassandra 架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;图数据库&quot;&gt;图数据库&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/fNcl65g.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png&quot; /&gt;资料来源：图数据库&amp;lt;/a&amp;gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;抽象模型： 图&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。&lt;/p&gt;

&lt;p&gt;图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过 &lt;a href=&quot;#表述性状态转移rest&quot;&gt;REST API&lt;/a&gt; 访问。&lt;/p&gt;

&lt;h5 id=&quot;相关资源和延伸阅读图&quot;&gt;相关资源和延伸阅读：图&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Graph_database&quot;&gt;图数据库&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://neo4j.com/&quot;&gt;Neo4j&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.twitter.com/2010/introducing-flockdb&quot;&gt;FlockDB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;来源及延伸阅读nosql&quot;&gt;来源及延伸阅读：NoSQL&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3342497/explanation-of-base-terminology&quot;&gt;数据库术语解释&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq&quot;&gt;NoSQL 数据库 - 调查及决策指南&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database&quot;&gt;可扩展性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=qI_g07C_Q5I&quot;&gt;NoSQL 介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://horicky.blogspot.com/2009/11/nosql-patterns.html&quot;&gt;NoSQL 模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-还是-nosql&quot;&gt;SQL 还是 NoSQL&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/wXGqG5f.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;https://www.infoq.com/articles/Transition-RDBMS-NoSQL/&quot;&gt;资料来源：从 RDBMS 转换到 NoSQL&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;选取 &lt;strong&gt;SQL&lt;/strong&gt; 的原因:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;结构化数据&lt;/li&gt;
  &lt;li&gt;严格的模式&lt;/li&gt;
  &lt;li&gt;关系型数据&lt;/li&gt;
  &lt;li&gt;需要复杂的联结操作&lt;/li&gt;
  &lt;li&gt;事务&lt;/li&gt;
  &lt;li&gt;清晰的扩展模式&lt;/li&gt;
  &lt;li&gt;既有资源更丰富：开发者、社区、代码库、工具等&lt;/li&gt;
  &lt;li&gt;通过索引进行查询非常快&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选取 &lt;strong&gt;NoSQL&lt;/strong&gt; 的原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;半结构化数据&lt;/li&gt;
  &lt;li&gt;动态或灵活的模式&lt;/li&gt;
  &lt;li&gt;非关系型数据&lt;/li&gt;
  &lt;li&gt;不需要复杂的联结操作&lt;/li&gt;
  &lt;li&gt;存储 TB （甚至 PB）级别的数据&lt;/li&gt;
  &lt;li&gt;高数据密集的工作负载&lt;/li&gt;
  &lt;li&gt;IOPS 高吞吐量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;适合 NoSQL 的示例数据：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;埋点数据和日志数据&lt;/li&gt;
  &lt;li&gt;排行榜或者得分数据&lt;/li&gt;
  &lt;li&gt;临时数据，如购物车&lt;/li&gt;
  &lt;li&gt;频繁访问的（“热”）表&lt;/li&gt;
  &lt;li&gt;元数据／查找表&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;来源及延伸阅读sql-或-nosql&quot;&gt;来源及延伸阅读：SQL 或 NoSQL&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=w95murBkYmU&quot;&gt;扩展你的用户数到第一个千万&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sitepoint.com/sql-vs-nosql-differences/&quot;&gt;SQL 和 NoSQL 的不同&lt;/a&gt;
    &lt;h2 id=&quot;缓存&quot;&gt;缓存&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/Q6z24La.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html&quot;&gt;资料来源：可扩展的系统设计模式&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;缓存可以提高页面加载速度，并可以减少服务器和数据库的负载。在这个模型中，分发器先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省掉真正的处理。&lt;/p&gt;

&lt;p&gt;数据库分片均匀分布的读取是最好的。但是热门数据会让读取分布不均匀，这样就会造成瓶颈，如果在数据库前加个缓存，就会抹平不均匀的负载和突发流量对数据库的影响。&lt;/p&gt;

&lt;h3 id=&quot;客户端缓存&quot;&gt;客户端缓存&lt;/h3&gt;

&lt;p&gt;缓存可以位于客户端（操作系统或者浏览器），&lt;a href=&quot;#反向代理web-服务器&quot;&gt;服务端&lt;/a&gt;或者不同的缓存层。&lt;/p&gt;

&lt;h3 id=&quot;cdn-缓存&quot;&gt;CDN 缓存&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#内容分发网络cdn&quot;&gt;CDN&lt;/a&gt; 也被视为一种缓存。&lt;/p&gt;

&lt;h3 id=&quot;web-服务器缓存&quot;&gt;Web 服务器缓存&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#反向代理web-服务器&quot;&gt;反向代理&lt;/a&gt;和缓存（比如 &lt;a href=&quot;https://www.varnish-cache.org/&quot;&gt;Varnish&lt;/a&gt;）可以直接提供静态和动态内容。Web 服务器同样也可以缓存请求，返回相应结果而不必连接应用服务器。&lt;/p&gt;

&lt;h3 id=&quot;数据库缓存&quot;&gt;数据库缓存&lt;/h3&gt;

&lt;p&gt;数据库的默认配置中通常包含缓存级别，针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。&lt;/p&gt;

&lt;h3 id=&quot;应用缓存&quot;&gt;应用缓存&lt;/h3&gt;

&lt;p&gt;基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;least recently used (LRU)&lt;/a&gt; 的&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_algorithms&quot;&gt;缓存无效算法&lt;/a&gt;可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。&lt;/p&gt;

&lt;p&gt;Redis 有下列附加功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;持久性选项&lt;/li&gt;
  &lt;li&gt;内置数据结构比如有序集合和列表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有多个缓存级别，分为两大类：&lt;strong&gt;数据库查询&lt;/strong&gt;和&lt;strong&gt;对象&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;行级别&lt;/li&gt;
  &lt;li&gt;查询级别&lt;/li&gt;
  &lt;li&gt;完整的可序列化对象&lt;/li&gt;
  &lt;li&gt;完全渲染的 HTML&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，你应该尽量避免基于文件的缓存，因为这使得复制和自动缩放很困难。&lt;/p&gt;

&lt;h3 id=&quot;数据库查询级别的缓存&quot;&gt;数据库查询级别的缓存&lt;/h3&gt;

&lt;p&gt;当你查询数据库的时候，将查询语句的哈希值与查询结果存储到缓存中。这种方法会遇到以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;很难用复杂的查询删除已缓存结果。&lt;/li&gt;
  &lt;li&gt;如果一条数据比如表中某条数据的一项被改变，则需要删除所有可能包含已更改项的缓存结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;对象级别的缓存&quot;&gt;对象级别的缓存&lt;/h3&gt;

&lt;p&gt;将您的数据视为对象，就像对待你的应用代码一样。让应用程序将数据从数据库中组合到类实例或数据结构中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果对象的基础数据已经更改了，那么从缓存中删掉这个对象。&lt;/li&gt;
  &lt;li&gt;允许异步处理：workers 通过使用最新的缓存对象来组装对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;建议缓存的内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户会话&lt;/li&gt;
  &lt;li&gt;完全渲染的 Web 页面&lt;/li&gt;
  &lt;li&gt;活动流&lt;/li&gt;
  &lt;li&gt;用户图数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;何时更新缓存&quot;&gt;何时更新缓存&lt;/h3&gt;

&lt;p&gt;由于你只能在缓存中存储有限的数据，所以你需要选择一个适用于你用例的缓存更新策略。&lt;/p&gt;

&lt;h4 id=&quot;缓存模式&quot;&gt;缓存模式&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/ONjORqk.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast&quot;&gt;资料来源：从缓存到内存数据网格&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;应用从存储器读写。缓存不和存储器直接交互，应用执行以下操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在缓存中查找记录，如果所需数据不在缓存中&lt;/li&gt;
  &lt;li&gt;从数据库中加载所需内容&lt;/li&gt;
  &lt;li&gt;将查找到的结果存储到缓存中&lt;/li&gt;
  &lt;li&gt;返回所需内容&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def get_user(self, user_id):
    user = cache.get(&quot;user.{0}&quot;, user_id)
    if user is None:
        user = db.query(&quot;SELECT * FROM users WHERE user_id = {0}&quot;, user_id)
        if user is not None:
            key = &quot;user.{0}&quot;.format(user_id)
            cache.set(key, json.dumps(user))
    return user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://memcached.org/&quot;&gt;Memcached&lt;/a&gt; 通常用这种方式使用。&lt;/p&gt;

&lt;p&gt;添加到缓存中的数据读取速度很快。缓存模式也称为延迟加载。只缓存所请求的数据，这避免了没有被请求的数据占满了缓存空间。&lt;/p&gt;

&lt;h5 id=&quot;缓存的缺点&quot;&gt;缓存的缺点：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;请求的数据如果不在缓存中就需要经过三个步骤来获取数据，这会导致明显的延迟。&lt;/li&gt;
  &lt;li&gt;如果数据库中的数据更新了会导致缓存中的数据过时。这个问题需要通过设置 TTL 强制更新缓存或者直写模式来缓解这种情况。&lt;/li&gt;
  &lt;li&gt;当一个节点出现故障的时候，它将会被一个新的节点替代，这增加了延迟的时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;直写模式&quot;&gt;直写模式&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/0vBc0hN.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.slideshare.net/jboner/scalability-availability-stability-patterns/&quot;&gt;资料来源：可扩展性、可用性、稳定性、模式&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;应用使用缓存作为主要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应用向缓存中添加/更新数据&lt;/li&gt;
  &lt;li&gt;缓存同步地写入数据存储&lt;/li&gt;
  &lt;li&gt;返回所需内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应用代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set_user(12345, {&quot;foo&quot;:&quot;bar&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缓存代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def set_user(user_id, values):
    user = db.query(&quot;UPDATE Users WHERE id = {0}&quot;, user_id, values)
    cache.set(user_id, user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于存写操作所以直写模式整体是一种很慢的操作，但是读取刚写入的数据很快。相比读取数据，用户通常比较能接受更新数据时速度较慢。缓存中的数据不会过时。&lt;/p&gt;

&lt;h5 id=&quot;直写模式的缺点&quot;&gt;直写模式的缺点：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;由于故障或者缩放而创建的新的节点，新的节点不会缓存，直到数据库更新为止。缓存应用直写模式可以缓解这个问题。&lt;/li&gt;
  &lt;li&gt;写入的大多数数据可能永远都不会被读取，用 TTL 可以最小化这种情况的出现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;回写模式&quot;&gt;回写模式&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/rgSrvjG.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.slideshare.net/jboner/scalability-availability-stability-patterns/&quot;&gt;资料来源：可扩展性、可用性、稳定性、模式&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;在回写模式中，应用执行以下操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在缓存中增加或者更新条目&lt;/li&gt;
  &lt;li&gt;异步写入数据，提高写入性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;回写模式的缺点&quot;&gt;回写模式的缺点：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;缓存可能在其内容成功存储之前丢失数据。&lt;/li&gt;
  &lt;li&gt;执行直写模式比缓存或者回写模式更复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;刷新&quot;&gt;刷新&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/kxtjqgE.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&amp;lt;a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast&amp;gt;资料来源：从缓存到内存数据网格&amp;lt;/a&amp;gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;你可以将缓存配置成在到期之前自动刷新最近访问过的内容。&lt;/p&gt;

&lt;p&gt;如果缓存可以准确预测将来可能请求哪些数据，那么刷新可能会导致延迟与读取时间的降低。&lt;/p&gt;

&lt;h5 id=&quot;刷新的缺点&quot;&gt;刷新的缺点：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;不能准确预测到未来需要用到的数据可能会导致性能不如不使用刷新。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;缓存的缺点-1&quot;&gt;缓存的缺点：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;需要保持缓存和真实数据源之间的一致性，比如数据库根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_algorithms&quot;&gt;缓存无效&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;需要改变应用程序比如增加 Redis 或者 memcached。&lt;/li&gt;
  &lt;li&gt;无效缓存是个难题，什么时候更新缓存是与之相关的复杂问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;相关资源和延伸阅读-1&quot;&gt;相关资源和延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast&quot;&gt;从缓存到内存数据&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html&quot;&gt;可扩展系统设计模式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lethain.com/introduction-to-architecting-systems-for-scale/&quot;&gt;可缩放系统构架介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/jboner/scalability-availability-stability-patterns/&quot;&gt;可扩展性，可用性，稳定性和模式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache&quot;&gt;可扩展性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html&quot;&gt;AWS ElastiCache 策略&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;异步&quot;&gt;异步&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/54GYsSx.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&amp;lt;a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer&amp;gt;资料来源：可缩放系统构架介绍&amp;lt;/a&amp;gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;异步工作流有助于减少那些原本顺序执行的请求时间。它们可以通过提前进行一些耗时的工作来帮助减少请求时间，比如定期汇总数据。&lt;/p&gt;

&lt;h3 id=&quot;消息队列&quot;&gt;消息队列&lt;/h3&gt;

&lt;p&gt;消息队列接收，保留和传递消息。如果按顺序执行操作太慢的话，你可以使用有以下工作流的消息队列：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应用程序将作业发布到队列，然后通知用户作业状态&lt;/li&gt;
  &lt;li&gt;一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得看上去像是任务已经完成了。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt; 是一个令人满意的简单的消息代理，但是消息有可能会丢失。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt; 很受欢迎但是要求你适应「AMQP」协议并且管理你自己的节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon SQS&lt;/strong&gt; 是被托管的，但可能具有高延迟，并且消息可能会被传送两次。&lt;/p&gt;

&lt;h3 id=&quot;任务队列&quot;&gt;任务队列&lt;/h3&gt;

&lt;p&gt;任务队列接收任务及其相关数据，运行它们，然后传递其结果。 它们可以支持调度，并可用于在后台运行计算密集型作业。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Celery&lt;/strong&gt; 支持调度，主要是用 Python 开发的。&lt;/p&gt;

&lt;h3 id=&quot;背压&quot;&gt;背压&lt;/h3&gt;

&lt;p&gt;如果队列开始明显增长，那么队列大小可能会超过内存大小，导致高速缓存未命中，磁盘读取，甚至性能更慢。&lt;a href=&quot;http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html&quot;&gt;背压&lt;/a&gt;可以通过限制队列大小来帮助我们，从而为队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将得到服务器忙或者 HTTP 503 状态码，以便稍后重试。客户端可以在稍后时间重试该请求，也许是&lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_backoff&quot;&gt;指数退避&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;异步的缺点&quot;&gt;异步的缺点：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;简单的计算和实时工作流等用例可能更适用于同步操作，因为引入队列可能会增加延迟和复杂性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;相关资源和延伸阅读-2&quot;&gt;相关资源和延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=1KRYH75wgy4&quot;&gt;这是一个数字游戏&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html&quot;&gt;超载时应用背压&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Little%27s_law&quot;&gt;利特尔法则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function&quot;&gt;消息队列与任务队列有什么区别？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;通讯&quot;&gt;通讯&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/5KeocQs.jpg&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&amp;lt;a href=http://www.escotal.com/osilayer.html&amp;gt;资料来源：OSI 7层模型&amp;lt;/a&amp;gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;h3 id=&quot;超文本传输协议http&quot;&gt;超文本传输协议（HTTP）&lt;/h3&gt;

&lt;p&gt;HTTP 是一种在客户端和服务器之间编码和传输数据的方法。它是一个请求/响应协议：客户端和服务端针对相关内容和完成状态信息的请求和响应。HTTP 是独立的，允许请求和响应流经许多执行负载均衡，缓存，加密和压缩的中间路由器和服务器。&lt;/p&gt;

&lt;p&gt;一个基本的 HTTP 请求由一个动词（方法）和一个资源（端点）组成。 以下是常见的 HTTP 动词：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;动词&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;*幂等&lt;/th&gt;
      &lt;th&gt;安全性&lt;/th&gt;
      &lt;th&gt;可缓存&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;GET&lt;/td&gt;
      &lt;td&gt;读取资源&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POST&lt;/td&gt;
      &lt;td&gt;创建资源或触发处理数据的进程&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes，如果回应包含刷新信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PUT&lt;/td&gt;
      &lt;td&gt;创建或替换资源&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PATCH&lt;/td&gt;
      &lt;td&gt;部分更新资源&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes，如果回应包含刷新信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DELETE&lt;/td&gt;
      &lt;td&gt;删除资源&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;多次执行不会产生不同的结果&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;HTTP 是依赖于较低级协议（如 &lt;strong&gt;TCP&lt;/strong&gt; 和 &lt;strong&gt;UDP&lt;/strong&gt;）的应用层协议。&lt;/p&gt;

&lt;h4 id=&quot;来源及延伸阅读http&quot;&gt;来源及延伸阅读：HTTP&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol&quot;&gt;README&lt;/a&gt;    +&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.nginx.com/resources/glossary/http/&quot;&gt;HTTP 是什么？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol&quot;&gt;HTTP 和 TCP 的区别&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1&quot;&gt;PUT 和 PATCH的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;传输控制协议tcp&quot;&gt;传输控制协议（TCP）&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/JdAsdvG.jpg&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/&quot;&gt;资料来源：如何制作多人游戏&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;TCP 是通过 &lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_Protocol&quot;&gt;IP 网络&lt;/a&gt;的面向连接的协议。 使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Handshaking&quot;&gt;握手&lt;/a&gt;建立和断开连接。 发送的所有数据包保证以原始顺序到达目的地，用以下措施保证数据包不被损坏：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个数据包的序列号和&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation&quot;&gt;校验码&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)&quot;&gt;确认包&lt;/a&gt;和自动重传&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。TCP 实行&lt;a href=&quot;https://en.wikipedia.org/wiki/Flow_control_(data)&quot;&gt;流量控制&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Network_congestion#Congestion_control&quot;&gt;拥塞控制&lt;/a&gt;。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。&lt;/p&gt;

&lt;p&gt;为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，也就是说，一个 &lt;a href=&quot;#memcached&quot;&gt;memcached&lt;/a&gt; 服务器。&lt;a href=&quot;https://en.wikipedia.org/wiki/Connection_pool&quot;&gt;连接池&lt;/a&gt; 可以帮助除了在适用的情况下切换到 UDP。&lt;/p&gt;

&lt;p&gt;TCP  对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。&lt;/p&gt;

&lt;p&gt;以下情况使用 TCP 代替 UDP：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你需要数据完好无损。&lt;/li&gt;
  &lt;li&gt;你想对网络吞吐量自动进行最佳评估。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;用户数据报协议udp&quot;&gt;用户数据报协议（UDP）&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/yzDrJtA.jpg&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1&quot;&gt;资料来源：如何制作多人游戏&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。&lt;/p&gt;

&lt;p&gt;UDP 可以通过广播将数据报发送至子网内的所有设备。这对 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol&quot;&gt;DHCP&lt;/a&gt; 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。&lt;/p&gt;

&lt;p&gt;UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。&lt;/p&gt;

&lt;p&gt;以下情况使用 UDP 代替 TCP：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你需要低延迟&lt;/li&gt;
  &lt;li&gt;相对于数据丢失更糟的是数据延迟&lt;/li&gt;
  &lt;li&gt;你想实现自己的错误校正方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;来源及延伸阅读tcp-与-udp&quot;&gt;来源及延伸阅读：TCP 与 UDP&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/&quot;&gt;游戏编程的网络&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/&quot;&gt;TCP 与 UDP 的关键区别&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp&quot;&gt;TCP 与 UDP 的不同&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;传输控制协议&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/User_Datagram_Protocol&quot;&gt;用户数据报协议&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf&quot;&gt;Memcache 在 Facebook 的扩展&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;远程过程调用协议rpc&quot;&gt;远程过程调用协议（RPC）&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/iF4Mkb5.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview&quot;&gt;Source: Crack the system design interview&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;在 RPC 中，客户端会去调用另一个地址空间（通常是一个远程服务器）里的方法。调用代码看起来就像是调用的是一个本地方法，客户端和服务器交互的具体过程被抽象。远程调用相对于本地调用一般较慢而且可靠性更差，因此区分两者是有帮助的。热门的 RPC 框架包括 &lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;Protobuf&lt;/a&gt;、&lt;a href=&quot;https://thrift.apache.org/&quot;&gt;Thrift&lt;/a&gt; 和 &lt;a href=&quot;https://avro.apache.org/docs/current/&quot;&gt;Avro&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;RPC 是一个“请求-响应”协议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;客户端程序&lt;/strong&gt; ── 调用客户端存根程序。就像调用本地方法一样，参数会被压入栈中。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;客户端 stub 程序&lt;/strong&gt; ── 将请求过程的 id 和参数打包进请求信息中。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;客户端通信模块&lt;/strong&gt; ── 将信息从客户端发送至服务端。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;服务端通信模块&lt;/strong&gt; ── 将接受的包传给服务端存根程序。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;服务端 stub 程序&lt;/strong&gt; ── 将结果解包，依据过程 id 调用服务端方法并将参数传递过去。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RPC 调用示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /someoperation?data=anId

POST /anotheroperation
{
  &quot;data&quot;:&quot;anId&quot;;
  &quot;anotherdata&quot;: &quot;another value&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RPC 专注于暴露方法。RPC 通常用于处理内部通讯的性能问题，这样你可以手动处理本地调用以更好的适应你的情况。&lt;/p&gt;

&lt;p&gt;当以下情况时选择本地库（也就是 SDK）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你知道你的目标平台。&lt;/li&gt;
  &lt;li&gt;你想控制如何访问你的“逻辑”。&lt;/li&gt;
  &lt;li&gt;你想对发生在你的库中的错误进行控制。&lt;/li&gt;
  &lt;li&gt;性能和终端用户体验是你最关心的事。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;遵循 &lt;strong&gt;REST&lt;/strong&gt; 的 HTTP API 往往更适用于公共 API。&lt;/p&gt;

&lt;h4 id=&quot;缺点rpc&quot;&gt;缺点：RPC&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;RPC 客户端与服务实现捆绑地很紧密。&lt;/li&gt;
  &lt;li&gt;一个新的 API 必须在每一个操作或者用例中定义。&lt;/li&gt;
  &lt;li&gt;RPC 很难调试。&lt;/li&gt;
  &lt;li&gt;你可能没办法很方便的去修改现有的技术。举个例子，如果你希望在 &lt;a href=&quot;http://www.squid-cache.org/&quot;&gt;Squid&lt;/a&gt; 这样的缓存服务器上确保 &lt;a href=&quot;http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/&quot;&gt;RPC 被正确缓存&lt;/a&gt;的话可能需要一些额外的努力了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;表述性状态转移rest&quot;&gt;表述性状态转移（REST）&lt;/h3&gt;

&lt;p&gt;REST 是一种强制的客户端/服务端架构设计模型，客户端基于服务端管理的一系列资源操作。服务端提供修改或获取资源的接口。所有的通信必须是无状态和可缓存的。&lt;/p&gt;

&lt;p&gt;RESTful 接口有四条规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;标志资源（HTTP 里的 URI）&lt;/strong&gt; ── 无论什么操作都使用同一个 URI。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;表示的改变（HTTP 的动作）&lt;/strong&gt; ── 使用动作, headers 和 body。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可自我描述的错误信息（HTTP 中的 status code）&lt;/strong&gt; ── 使用状态码，不要重新造轮子。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://restcookbook.com/Basics/hateoas/&quot;&gt;HATEOAS&lt;/a&gt;（HTTP 中的HTML 接口）&lt;/strong&gt; ── 你的 web 服务器应该能够通过浏览器访问。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;REST 请求的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /someresources/anId

PUT /someresources/anId
{&quot;anotherdata&quot;: &quot;another value&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;REST 关注于暴露数据。它减少了客户端／服务端的耦合程度，经常用于公共 HTTP API 接口设计。REST 使用更通常与规范化的方法来通过 URI 暴露资源，&lt;a href=&quot;https://github.com/for-GET/know-your-http-well/blob/master/headers.md&quot;&gt;通过 header 来表述&lt;/a&gt;并通过 GET、POST、PUT、DELETE 和 PATCH 这些动作来进行操作。因为无状态的特性，REST 易于横向扩展和隔离。&lt;/p&gt;

&lt;h4 id=&quot;缺点rest&quot;&gt;缺点：REST&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;由于 REST 将重点放在暴露数据，所以当资源不是自然组织的或者结构复杂的时候它可能无法很好的适应。举个例子，返回过去一小时中与特定事件集匹配的更新记录这种操作就很难表示为路径。使用 REST，可能会使用 URI 路径，查询参数和可能的请求体来实现。&lt;/li&gt;
  &lt;li&gt;REST 一般依赖几个动作（GET、POST、PUT、DELETE 和 PATCH），但有时候仅仅这些没法满足你的需要。举个例子，将过期的文档移动到归档文件夹里去，这样的操作可能没法简单的用上面这几个 verbs 表达。&lt;/li&gt;
  &lt;li&gt;为了渲染单个页面，获取被嵌套在层级结构中的复杂资源需要客户端，服务器之间多次往返通信。例如，获取博客内容及其关联评论。对于使用不确定网络环境的移动应用来说，这些多次往返通信是非常麻烦的。&lt;/li&gt;
  &lt;li&gt;随着时间的推移，更多的字段可能会被添加到 API 响应中，较旧的客户端将会接收到所有新的数据字段，即使是那些它们不需要的字段，结果它会增加负载大小并引起更大的延迟。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rpc-与-rest-比较&quot;&gt;RPC 与 REST 比较&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;RPC&lt;/th&gt;
      &lt;th&gt;REST&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;注册&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;POST&lt;/strong&gt; /signup&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;POST&lt;/strong&gt; /persons&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;注销&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;POST&lt;/strong&gt; /resign&lt;br /&gt;{&lt;br /&gt;“personid”: “1234”&lt;br /&gt;}&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;DELETE&lt;/strong&gt; /persons/1234&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;读取用户信息&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;GET&lt;/strong&gt; /readPerson?personid=1234&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;GET&lt;/strong&gt; /persons/1234&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;读取用户物品列表&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;GET&lt;/strong&gt; /readUsersItemsList?personid=1234&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;GET&lt;/strong&gt; /persons/1234/items&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;向用户物品列表添加一项&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;POST&lt;/strong&gt; /addItemToUsersItemsList&lt;br /&gt;{&lt;br /&gt;“personid”: “1234”;&lt;br /&gt;“itemid”: “456”&lt;br /&gt;}&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;POST&lt;/strong&gt; /persons/1234/items&lt;br /&gt;{&lt;br /&gt;“itemid”: “456”&lt;br /&gt;}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;更新一个物品&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;POST&lt;/strong&gt; /modifyItem&lt;br /&gt;{&lt;br /&gt;“itemid”: “456”;&lt;br /&gt;“key”: “value”&lt;br /&gt;}&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;PUT&lt;/strong&gt; /items/456&lt;br /&gt;{&lt;br /&gt;“key”: “value”&lt;br /&gt;}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;删除一个物品&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;POST&lt;/strong&gt; /removeItem&lt;br /&gt;{&lt;br /&gt;“itemid”: “456”&lt;br /&gt;}&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;DELETE&lt;/strong&gt; /items/456&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;strong&gt;&lt;a href=&quot;https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc&quot;&gt;资料来源：你真的知道你为什么更喜欢 REST 而不是 RPC 吗&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;h4 id=&quot;来源及延伸阅读rest-与-rpc&quot;&gt;来源及延伸阅读：REST 与 RPC&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/&quot;&gt;你真的知道你为什么更喜欢 REST 而不是 RPC 吗&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://programmers.stackexchange.com/a/181186&quot;&gt;什么时候 RPC 比 REST 更合适？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/15056878/rest-vs-json-rpc&quot;&gt;REST vs JSON-RPC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/&quot;&gt;揭开 RPC 和 REST 的神秘面纱&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs&quot;&gt;使用 REST 的缺点是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview&quot;&gt;破解系统设计面试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://code.facebook.com/posts/1468950976659943/&quot;&gt;Thrift&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://arstechnica.com/civis/viewtopic.php?t=1190508&quot;&gt;为什么在内部使用 REST 而不是 RPC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;安全&quot;&gt;安全&lt;/h2&gt;

&lt;p&gt;这一部分需要更多内容。&lt;a href=&quot;#贡献&quot;&gt;一起来吧&lt;/a&gt;！&lt;/p&gt;

&lt;p&gt;安全是一个宽泛的话题。除非你有相当的经验、安全方面背景或者正在申请的职位要求安全知识，你不需要了解安全基础知识以外的内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在运输和等待过程中加密&lt;/li&gt;
  &lt;li&gt;对所有的用户输入和从用户那里发来的参数进行处理以防止 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS&lt;/a&gt; 和 &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL 注入&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;使用参数化的查询来防止 SQL 注入。&lt;/li&gt;
  &lt;li&gt;使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;最小权限原则&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;来源及延伸阅读-12&quot;&gt;来源及延伸阅读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/FallibleInc/security-guide-for-developers&quot;&gt;为开发者准备的安全引导&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet&quot;&gt;OWASP top ten&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;

&lt;p&gt;一些时候你会被要求做出保守估计。比如，你可能需要估计从磁盘中生成 100 张图片的缩略图需要的时间或者一个数据结构需要多少的内存。&lt;strong&gt;2 的次方表&lt;/strong&gt;和&lt;strong&gt;每个开发者都需要知道的一些时间数据&lt;/strong&gt;（译注：OSChina 上有这篇文章的&lt;a href=&quot;https://www.oschina.net/news/30009/every-programmer-should-know&quot;&gt;译文&lt;/a&gt;）都是一些很方便的参考资料。&lt;/p&gt;

&lt;h3 id=&quot;2-的次方表&quot;&gt;2 的次方表&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;来源及延伸阅读-13&quot;&gt;来源及延伸阅读&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Power_of_two&quot;&gt;2 的次方&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;每个程序员都应该知道的延迟数&quot;&gt;每个程序员都应该知道的延迟数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA-&amp;gt;Netherlands-&amp;gt;CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于上述数字的指标：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从磁盘以 30 MB/s 的速度顺序读取&lt;/li&gt;
  &lt;li&gt;以 100 MB/s 从 1 Gbps 的以太网顺序读取&lt;/li&gt;
  &lt;li&gt;从 SSD 以 1 GB/s 的速度读取&lt;/li&gt;
  &lt;li&gt;以 4 GB/s 的速度从主存读取&lt;/li&gt;
  &lt;li&gt;每秒能绕地球 6-7 圈&lt;/li&gt;
  &lt;li&gt;数据中心内每秒有 2,000 次往返&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;延迟数可视化&quot;&gt;延迟数可视化&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;来源及延伸阅读-14&quot;&gt;来源及延伸阅读&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;每个程序员都应该知道的延迟数 — 1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/hellerbarde/2843375&quot;&gt;每个程序员都应该知道的延迟数 — 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf&quot;&gt;关于建设大型分布式系统的的设计方案、课程和建议&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf&quot;&gt;关于建设大型可拓展分布式系统的软件工程咨询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;其它的系统设计面试题&quot;&gt;其它的系统设计面试题&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;常见的系统设计面试问题，给出了如何解决的方案链接&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;问题&lt;/th&gt;
      &lt;th&gt;引用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似于 Dropbox 的文件同步服务&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=PE4gwstWhmc&quot;&gt;youtube.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似于 Google 的搜索引擎&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://queue.acm.org/detail.cfm?id=988407&quot;&gt;queue.acm.org&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search&quot;&gt;stackexchange.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://www.ardendertat.com/2012/01/11/implementing-search-engines/&quot;&gt;ardendertat.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://infolab.stanford.edu/~backrub/google.html&quot;&gt;stanford.edu&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似于 Google 的可扩展网络爬虫&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch&quot;&gt;quora.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计 Google 文档&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://code.google.com/p/google-mobwrite/&quot;&gt;code.google.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://neil.fraser.name/writing/sync/&quot;&gt;neil.fraser.name&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似 Redis 的键值存储&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/dvirsky/introduction-to-redis&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似 Memcached 的缓存系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/oemebamo/introduction-to-memcached&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似亚马逊的推荐系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://tech.hulu.com/blog/2011/09/19/recommendation-system.html&quot;&gt;hulu.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://ijcai13.org/files/tutorial_slides/td3.pdf&quot;&gt;ijcai13.org&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似 Bitly 的短链接系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://n00tc0d3r.blogspot.com/&quot;&gt;n00tc0d3r.blogspot.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似 WhatsApp 的聊天应用&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html&quot;&gt;highscalability.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似 Instagram 的图片分享系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/flickr-architecture&quot;&gt;highscalability.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html&quot;&gt;highscalability.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计 Facebook 的新闻推荐方法&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed&quot;&gt;quora.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed&quot;&gt;quora.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计 Facebook 的时间线系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://www.facebook.com/note.php?note_id=10150468255628920&quot;&gt;facebook.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html&quot;&gt;highscalability.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计 Facebook 的聊天系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf&quot;&gt;erlang-factory.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://www.facebook.com/note.php?note_id=14218138919&amp;amp;id=9445547199&amp;amp;index=0&quot;&gt;facebook.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似 Facebook 的图表搜索系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920&quot;&gt;facebook.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920&quot;&gt;facebook.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920&quot;&gt;facebook.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似 CloudFlare 的内容传递网络&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;amp;context=compsci&quot;&gt;cmu.edu&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计类似 Twitter 的热门话题系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/&quot;&gt;michael-noll.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/&quot;&gt;snikolov .wordpress.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一个随机 ID 生成系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://blog.twitter.com/2010/announcing-snowflake&quot;&gt;blog.twitter.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://github.com/twitter/snowflake/&quot;&gt;github.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;返回一定时间段内次数前 k 高的请求&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://icmi.cs.ucsb.edu/research/tech_reports/reports/2005-23.pdf&quot;&gt;ucsb.edu&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf&quot;&gt;wpi.edu&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一个数据源于多个数据中心的服务系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html&quot;&gt;highscalability.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一个多人网络卡牌游戏&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html&quot;&gt;indieflashblog.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://buildnewgames.com/real-time-multiplayer/&quot;&gt;buildnewgames.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设计一个垃圾回收系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/&quot;&gt;stuffwithstuff.com&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf&quot;&gt;washington.edu&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;添加更多的系统设计问题&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#贡献&quot;&gt;贡献&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;真实架构&quot;&gt;真实架构&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于现实中真实的系统是怎么设计的文章。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/images/2022/TcUo2fw.png&quot; /&gt;
  &lt;br /&gt;
  &lt;strong&gt;&lt;a href=&quot;https://www.infoq.com/presentations/Twitter-Timeline-Scalability&quot;&gt;Source: Twitter timelines at scale&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不要专注于以下文章的细节，专注于以下方面：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发现这些文章中的共同的原则、技术和模式。&lt;/li&gt;
  &lt;li&gt;学习每个组件解决哪些问题，什么情况下使用，什么情况下不适用&lt;/li&gt;
  &lt;li&gt;复习学过的文章&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;系统&lt;/th&gt;
      &lt;th&gt;引用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Data processing&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;MapReduce&lt;/strong&gt; - Google的分布式数据处理&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf&quot;&gt;research.google.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data processing&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Spark&lt;/strong&gt; - Databricks 的分布式数据处理&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/AGrishchenko/apache-spark-architecture&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data processing&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Storm&lt;/strong&gt; - Twitter 的分布式数据处理&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/previa/storm-16094009&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data processing&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Druid&lt;/strong&gt; Meta Market的大规模数据实时查询系统，Google的Dremel的开源实现&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://research.google/pubs/pub36632.pdf&quot;&gt;Dremel: Interactive Analysis of Web-Scale Datasets&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data processing&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Presto&lt;/strong&gt; - Facebook的大规模数据实时查询系统，Google的Dremel的开源实现&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://research.google/pubs/pub36632.pdf&quot;&gt;Dremel: Interactive Analysis of Web-Scale Datasets&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Bigtable&lt;/strong&gt; - Google 的列式数据库&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf&quot;&gt;harvard.edu&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;HBase&lt;/strong&gt; - Bigtable 的开源实现&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/alexbaranau/intro-to-hbase&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Cassandra&lt;/strong&gt; - Facebook 的列式数据库&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;DynamoDB&lt;/strong&gt; - Amazon 的文档数据库&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf&quot;&gt;harvard.edu&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;MongoDB&lt;/strong&gt; - 文档数据库&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/mdirolf/introduction-to-mongodb&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Spanner&lt;/strong&gt; - Google 的全球分布数据库&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://research.google.com/archive/spanner-osdi2012.pdf&quot;&gt;research.google.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Memcached&lt;/strong&gt; - 分布式内存缓存系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/oemebamo/introduction-to-memcached&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Redis&lt;/strong&gt; - 能够持久化及具有值类型的分布式内存缓存系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/dvirsky/introduction-to-redis&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;LevelDB&lt;/strong&gt; - Google 开源高性能持久化KV存储引擎&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/google/leveldb&quot;&gt;leveldb&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data store&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;RocksDB&lt;/strong&gt; -  Facebook 基于 LevelDB 开发的一款提供键值存储与读写功能的 LSM-tree 架构引擎&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://rocksdb.org&quot;&gt;RocksDB&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;File system&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Google File System (GFS)&lt;/strong&gt; - 分布式文件系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf&quot;&gt;research.google.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;File system&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Hadoop File System (HDFS)&lt;/strong&gt; - GFS 的开源实现&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html&quot;&gt;apache.org&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Misc&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Chubby&lt;/strong&gt; - Google 的分布式系统的低耦合锁服务&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf&quot;&gt;research.google.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Misc&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Dapper&lt;/strong&gt; - 分布式系统跟踪基础设施&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf&quot;&gt;research.google.com&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Misc&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Kafka&lt;/strong&gt; - LinkedIn 的发布订阅消息系统&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/mumrah/kafka-talk-tri-hug&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Misc&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Zookeeper&lt;/strong&gt; - 集中的基础架构和协调服务&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper&quot;&gt;slideshare.net&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Graph Processing&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Pregel&lt;/strong&gt; - Goole针对大规模图算法设计的分布式系统框架&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://doi.acm.org/10.1145/1807167.1807184&quot;&gt;paper&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;添加更多&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#贡献&quot;&gt;贡献&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;公司的系统架构&quot;&gt;公司的系统架构&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Company&lt;/th&gt;
      &lt;th&gt;Reference(s)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Amazon&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/amazon-architecture&quot;&gt;Amazon 的架构&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cinchcast&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html&quot;&gt;每天产生 1500 小时的音频&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DataSift&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html&quot;&gt;每秒实时挖掘 120000 条 tweet&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DropBox&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=PE4gwstWhmc&quot;&gt;我们如何缩放 Dropbox&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ESPN&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html&quot;&gt;每秒操作 100000 次&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Google&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/google-architecture&quot;&gt;Google 的架构&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Instagram&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html&quot;&gt;1400 万用户，达到兆级别的照片存储&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances&quot;&gt;是什么在驱动 Instagram&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Justin.tv&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html&quot;&gt;Justin.Tv 的直播广播架构&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Facebook&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf&quot;&gt;Facebook 的可扩展 memcached&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf&quot;&gt;TAO: Facebook 社交图的分布式数据存储&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf&quot;&gt;Facebook 的图片存储&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Flickr&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/flickr-architecture&quot;&gt;Flickr 的架构&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mailbox&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html&quot;&gt;在 6 周内从 0 到 100 万用户&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Pinterest&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html&quot;&gt;从零到每月数十亿的浏览量&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html&quot;&gt;1800 万访问用户，10 倍增长，12 名员工&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Playfish&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html&quot;&gt;月用户量 5000 万并在不断增长&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PlentyOfFish&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/plentyoffish-architecture&quot;&gt;PlentyOfFish 的架构&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Salesforce&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html&quot;&gt;他们每天如何处理 13 亿笔交易&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stack Overflow&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html&quot;&gt;Stack Overflow 的架构&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TripAdvisor&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html&quot;&gt;40M 访问者，200M 页面浏览量，30TB 数据&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Tumblr&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html&quot;&gt;每月 150 亿的浏览量&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Twitter&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster&quot;&gt;Making Twitter 10000 percent faster&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html&quot;&gt;每天使用 MySQL 存储2.5亿条 tweet&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html&quot;&gt;150M 活跃用户，300K QPS，22 MB/S 的防火墙&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://www.infoq.com/presentations/Twitter-Timeline-Scalability&quot;&gt;可扩展时间表&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=5cKTP36HVgI&quot;&gt;Twitter 的大小数据&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=z8LU0Cj6BOU&quot;&gt;Twitter 的行为：规模超过 1 亿用户&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Uber&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html&quot;&gt;Uber 如何扩展自己的实时化市场&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WhatsApp&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html&quot;&gt;Facebook 用 190 亿美元购买 WhatsApp 的架构&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;YouTube&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=w5WVu624fY8&quot;&gt;YouTube 的可扩展性&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://highscalability.com/youtube-architecture&quot;&gt;YouTube 的架构&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;公司工程博客&quot;&gt;公司工程博客&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;你即将面试的公司的架构&lt;/p&gt;

  &lt;p&gt;你面对的问题可能就来自于同样领域&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://nerds.airbnb.com/&quot;&gt;Airbnb Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.atlassian.com/blog/&quot;&gt;Atlassian Developers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://cloudengineering.autodesk.com/blog/&quot;&gt;Autodesk Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/blogs/aws/&quot;&gt;AWS Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://word.bitly.com/&quot;&gt;Bitly Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.box.com/blog/engineering/&quot;&gt;Box Blogs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.cloudera.com/blog/&quot;&gt;Cloudera Developer Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tech.dropbox.com/&quot;&gt;Dropbox Tech Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://engineering.quora.com/&quot;&gt;Engineering at Quora&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ebaytechblog.com/&quot;&gt;Ebay Tech Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.evernote.com/tech/&quot;&gt;Evernote Tech Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://codeascraft.com/&quot;&gt;Etsy Code as Craft&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.facebook.com/Engineering&quot;&gt;Facebook Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://code.flickr.net/&quot;&gt;Flickr Code&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://engineering.foursquare.com/&quot;&gt;Foursquare Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.blog/category/engineering&quot;&gt;GitHub Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://googleresearch.blogspot.com/&quot;&gt;Google Research Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://engineering.groupon.com/&quot;&gt;Groupon Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://engineering.heroku.com/&quot;&gt;Heroku Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://product.hubspot.com/blog/topic/engineering&quot;&gt;Hubspot Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://highscalability.com/&quot;&gt;High Scalability&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://instagram-engineering.tumblr.com/&quot;&gt;Instagram Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/blogs/&quot;&gt;Intel Software Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogs.janestreet.com/category/ocaml/&quot;&gt;Jane Street Tech Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://engineering.linkedin.com/blog&quot;&gt;LinkedIn Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://engineering.microsoft.com/&quot;&gt;Microsoft Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/pythonengineering/&quot;&gt;Microsoft Python Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://techblog.netflix.com/&quot;&gt;Netflix Tech Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://devblog.paypal.com/category/engineering/&quot;&gt;Paypal Developer Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://engineering.pinterest.com/&quot;&gt;Pinterest Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://engineering.quora.com/&quot;&gt;Quora Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.redditblog.com/&quot;&gt;Reddit Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.salesforce.com/blogs/engineering/&quot;&gt;Salesforce Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://slack.engineering/&quot;&gt;Slack Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labs.spotify.com/&quot;&gt;Spotify Labs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.twilio.com/engineering&quot;&gt;Twilio Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://engineering.twitter.com/&quot;&gt;Twitter Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://eng.uber.com/&quot;&gt;Uber Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://yahooeng.tumblr.com/&quot;&gt;Yahoo Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://engineeringblog.yelp.com/&quot;&gt;Yelp Engineering Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zynga.com/blogs/engineering&quot;&gt;Zynga Engineering Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;来源及延伸阅读-15&quot;&gt;来源及延伸阅读&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/kilimchoi/engineering-blogs&quot;&gt;kilimchoi/engineering-blogs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    <link>https://dyxu.net/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/system-design.html</link>
    <guid>https://dyxu.net/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/system-design</guid>
    <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>算法刷题总结【转载】</title>
    <description>
&lt;p&gt;算法刷题总结，原文&lt;a href=&quot;https://github.com/labuladong/fucking-algorithm&quot;&gt;labuladong&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;h3 id=&quot;第零章必读文章&quot;&gt;第零章、必读文章&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=ZYaXOSVM3YBIeRWm7E_jcQ&quot;&gt;学习算法和刷题的框架思维&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=_XhcgHrI15PsPp-Ie87p3w&quot;&gt;我的刷题心得&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=509&quot;&gt;动态规划解题套路框架&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=51&quot;&gt;回溯算法解题套路框架&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=111&quot;&gt;BFS 算法解题套路框架&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=104&quot;&gt;手把手带你刷二叉树（纲领篇）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=21&quot;&gt;一文搞懂单链表的六大解题套路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=200&quot;&gt;一文秒杀所有岛屿题目&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=704&quot;&gt;我写了首诗，让你闭着眼睛也能写对二分搜索&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=76&quot;&gt;我写了首诗，把滑动窗口算法算法变成了默写题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=121&quot;&gt;一个方法团灭 LeetCode 股票买卖问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=198&quot;&gt;一个方法团灭 LeetCode 打家劫舍问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=15&quot;&gt;一个方法团灭 nSum 问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=ucGZavJVKNCJ5j7T15voZA&quot;&gt;提高刷题幸福感的小技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第一章手把手刷数据结构&quot;&gt;第一章、手把手刷数据结构&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;手把手刷链表题目&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=21&quot;&gt;一文搞懂单链表的六大解题套路&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=206&quot;&gt;递归反转链表的一部分&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=25&quot;&gt;如何 K 个一组反转链表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=234&quot;&gt;如何判断回文链表&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;手把手刷二叉树&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=104&quot;&gt;手把手带你刷二叉树（纲领篇）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=226&quot;&gt;手把手带你刷二叉树（第一期）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=654&quot;&gt;手把手带你刷二叉树（第二期）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=652&quot;&gt;手把手带你刷二叉树（第三期）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=230&quot;&gt;手把手带你刷二叉搜索树（第一期）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=450&quot;&gt;手把手带你刷二叉搜索树（第二期）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=96&quot;&gt;手把手带你刷二叉搜索树（第三期）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=1373&quot;&gt;美团面试官：你对后序遍历一无所知&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=297&quot;&gt;二叉树的序列化，就那几个框架，枯燥至极&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=341&quot;&gt;题目不让我干什么，我偏要干什么&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=236&quot;&gt;Git原理之最近公共祖先&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=222&quot;&gt;如何计算完全二叉树的节点数&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=jI8_-E6rx2HVBOmuQOTgHg&quot;&gt;二叉树八股文：递归改迭代&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;手把手刷图算法&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=797&quot;&gt;图论基础&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=207&quot;&gt;拓扑排序详解及运用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=785&quot;&gt;二分图判定&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=323&quot;&gt;Union-Find算法详解&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=130&quot;&gt;Union-Find算法应用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=261&quot;&gt;Kruskal 最小生成树算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=bvi0wGdbtB4nkYye0yzmqg&quot;&gt;Prim 最小生成树算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=277&quot;&gt;众里寻他千百度：名流问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=743&quot;&gt;我写了一个模板，把 Dijkstra 算法变成了默写题&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;手把手设计数据结构&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=146&quot;&gt;算法就像搭乐高：带你手撸 LRU 算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=460&quot;&gt;算法就像搭乐高：带你手撸 LFU 算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=208&quot;&gt;前缀树算法模板秒杀五道算法题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=895&quot;&gt;数据结构设计：最大栈&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=295&quot;&gt;一道求中位数的算法题把我整不会了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=355&quot;&gt;设计朋友圈时间线功能&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=496&quot;&gt;单调栈结构解决三道算法题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=239&quot;&gt;单调队列结构解决滑动窗口问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=o7tdyLiYm668dpUWd-x7Lg&quot;&gt;二叉堆详解实现优先级队列&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=232&quot;&gt;队列实现栈以及栈实现队列&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;手把手刷数组题目&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=303&quot;&gt;小而美的算法技巧：前缀和数组&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=370&quot;&gt;小而美的算法技巧：差分数组&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=48&quot;&gt;二维数组的花式遍历技巧&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=167&quot;&gt;双指针技巧总结&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=76&quot;&gt;我写了首诗，把滑动窗口算法算法变成了默写题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=704&quot;&gt;我写了首诗，让你闭着眼睛也能写对二分搜索&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=875&quot;&gt;二分搜索怎么用？我又总结了套路&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=410&quot;&gt;我和快手面试官对二分搜索进行了深度探讨&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=870&quot;&gt;田忌赛马背后的算法决策&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=380&quot;&gt;给我常数时间，我可以删除/查找数组中的任意元素&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=528&quot;&gt;带权重的随机选择算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=316&quot;&gt;一道数组去重的算法题把我整不会了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=26&quot;&gt;如何去除有序数组的重复元素&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=1&quot;&gt;twoSum问题的核心思想&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第二章手把手刷动态规划&quot;&gt;第二章、手把手刷动态规划&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;动态规划基本技巧&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=509&quot;&gt;动态规划解题核心框架&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=300&quot;&gt;动态规划设计：最长递增子序列&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=qvlfyKBiXVX7CCwWFR-XKg&quot;&gt;最优子结构原理和 dp 数组遍历方向&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=931&quot;&gt;base case 和备忘录的初始值怎么定？&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=SnyN1Gn6DTLm0uJyp5l6CQ&quot;&gt;对动态规划进行降维打击&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=494&quot;&gt;动态规划和回溯算法到底谁是谁爹？&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;子序列类型问题&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=72&quot;&gt;经典动态规划：编辑距离&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=300&quot;&gt;动态规划设计：最长递增子序列&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=354&quot;&gt;二维递增子序列：信封嵌套问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=53&quot;&gt;动态规划设计：最大子数组&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=1143&quot;&gt;经典动态规划：最长公共子序列&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=516&quot;&gt;动态规划之子序列问题解题模板&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;背包类型问题&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=RXfnhSpVBmVneQjDSUSAVQ&quot;&gt;经典动态规划：0-1 背包问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=416&quot;&gt;经典动态规划：子集背包问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=518&quot;&gt;经典动态规划：完全背包问题&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;用动态规划玩游戏&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=64&quot;&gt;动态规划之最小路径和&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=174&quot;&gt;动态规划帮我通关了《魔塔》&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=514&quot;&gt;动态规划帮我通关了《辐射4》&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=787&quot;&gt;旅游省钱大法：加权最短路径&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=10&quot;&gt;经典动态规划：正则表达式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=xn4LjWfaKTPQeCXR0qDqZg&quot;&gt;经典动态规划：高楼扔鸡蛋&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=7XPGKe7bMkwovH95cnhang&quot;&gt;经典动态规划：高楼扔鸡蛋（进阶）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=312&quot;&gt;经典动态规划：戳气球&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=xTeOzqNiGJwbwIpS3ySZqw&quot;&gt;经典动态规划：博弈问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=651&quot;&gt;经典动态规划：四键键盘&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=198&quot;&gt;一个方法团灭 LeetCode 打家劫舍问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=121&quot;&gt;一个方法团灭 LeetCode 股票买卖问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=28&quot;&gt;有限状态机之 KMP 字符匹配算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=1312&quot;&gt;构造回文的最小插入次数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;贪心类型问题&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=435&quot;&gt;贪心算法之区间调度问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=253&quot;&gt;扫描线技巧：安排会议室&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=1024&quot;&gt;剪视频剪出一个贪心算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=55&quot;&gt;如何运用贪心思想玩跳跃游戏&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=134&quot;&gt;当老司机学会了贪心算法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第三章必知必会算法技巧&quot;&gt;第三章、必知必会算法技巧&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;暴力搜索算法&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=51&quot;&gt;回溯算法解题套路框架&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=698&quot;&gt;经典回溯算法：集合划分问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=78&quot;&gt;回溯算法团灭子集、排列、组合问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=37&quot;&gt;回溯算法最佳实践：解数独&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=22&quot;&gt;回溯算法最佳实践：括号生成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=111&quot;&gt;BFS 算法解题套路框架&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=773&quot;&gt;如何用 BFS 算法秒杀各种智力题&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;数学运算技巧&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=191&quot;&gt;常用的位操作&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=172&quot;&gt;讲两道常考的阶乘算法题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=204&quot;&gt;如何高效寻找素数&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=372&quot;&gt;如何高效进行模幂运算&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=268&quot;&gt;如何寻找缺失的元素&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=645&quot;&gt;如何同时寻找缺失和重复的元素&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=382&quot;&gt;如何在无限序列中随机抽取元素&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=292&quot;&gt;一行代码就能解决的算法题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=eCgxtBpsrZjJQ9KmhKrEJw&quot;&gt;几个反直觉的概率问题&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;其他算法技巧&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=215&quot;&gt;快速排序亲兄弟：快速选择算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=241&quot;&gt;分治算法详解：运算优先级&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=1288&quot;&gt;一个方法解决三道区间问题&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/algo/&quot;&gt;经典面试题&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=659&quot;&gt;谁能想到，斗地主也能玩出算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=3VjL7Gud1bQQrbjedzEhMQ&quot;&gt;东哥吃葡萄时竟然吃出一道算法题！&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=969&quot;&gt;烧饼排序算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=43&quot;&gt;字符串乘法计算&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=224&quot;&gt;如何实现一个计算器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=42&quot;&gt;如何高效解决接雨水问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=5&quot;&gt;如何寻找最长回文子串&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=20&quot;&gt;如何解决括号相关的问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=391&quot;&gt;如何判定完美矩形&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=855&quot;&gt;如何调度考生的座位&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/?qno=392&quot;&gt;二分查找高效判定子序列&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第四章通用计算机技术&quot;&gt;第四章、通用计算机技术&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=kJx07mbQQExV3JUGJo4nYw&quot;&gt;Linux 文件系统都是什么鬼&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=USb5e2Zoc0LRgRShRpTYfg&quot;&gt;Linux 的进程、线程、文件描述符是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=h3SXmZ2yMtOKEKdACUx1Ew&quot;&gt;关于 Linux shell 你必须知道的&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=vCtu4lkcoixJELH2t9r7pg&quot;&gt;Linux shell 的实用小技巧&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=p3rwjoCWN2WnH4xxtwDiyQ&quot;&gt;Linux 管道符原理大揭秘&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=lEAFW9ZSiqHJOfMnznPPHA&quot;&gt;一文看懂 session 和 cookie&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=HvZsBiNn9tPcq11fmWgcLQ&quot;&gt;加密算法的前身今世&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=VdeQpFCL3GGsfOKrIRW6Hw&quot;&gt;我用四个命令概括了 Git 的所有套路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://labuladong.github.io/article/wx.html?wx=rSc4b-mdZSLuqBmvPWF8Vw&quot;&gt;Git/SQL/正则表达式的在线练习平台&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    <link>https://dyxu.net/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithms-primer.html</link>
    <guid>https://dyxu.net/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithms-primer</guid>
    <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>延迟消息设计与实现【转载】</title>
    <description>
&lt;p&gt;&lt;strong&gt;本文转载自&lt;a href=&quot;https://mp.weixin.qq.com/s/eDMV25YqCPYjxQG-dvqSqQ&quot;&gt;博客&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/jkko123/p/7239420.html&quot;&gt;微信公众号&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-缘起&quot;&gt;1 缘起&lt;/h2&gt;

&lt;p&gt;很多时候，业务有“在一段时间之后，完成一个工作任务”的需求。&lt;/p&gt;

&lt;p&gt;例如：滴滴打车订单完成后，如果用户一直不评价，48小时后会将自动评价为5星。&lt;/p&gt;

&lt;p&gt;一般来说怎么实现这类“48小时后自动评价为5星”需求呢？&lt;/p&gt;

&lt;p&gt;常见方案：启动一个cron定时任务，每小时跑一次，将完成时间超过48小时的订单取出，置为5星，并把评价状态置为已评价。
假设订单表的结构为：&lt;code&gt;t_order(oid, finish_time, stars, status, …)&lt;/code&gt;，更具体的，定时任务每隔一个小时会这么做一次：
&lt;code&gt;select oid from t_order where finish_time &amp;gt; 48hours and status=0;&lt;/code&gt;
&lt;code&gt;update t_order set stars=5 and status=1 where oid in[…];&lt;/code&gt;
如果数据量很大，需要分页查询，分页update，这将会是一个for循环。&lt;/p&gt;

&lt;p&gt;方案的不足：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;轮询效率比较低&lt;/li&gt;
  &lt;li&gt;每次扫库，已经被执行过记录，仍然会被扫描（只是不会出现在结果集中），有重复计算的嫌疑&lt;/li&gt;
  &lt;li&gt;时效性不够好，如果每小时轮询一次，最差的情况下，时间误差会达到1小时&lt;/li&gt;
  &lt;li&gt;如果通过增加cron轮询频率来减少（3）中的时间误差，（1）中轮询低效和（2）中重复计算的问题会进一步凸显&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如何利用“延时消息”，对于每个任务只触发一次，保证效率的同时保证实时性，是今天要讨论的问题。&lt;/p&gt;

&lt;h2 id=&quot;2-高效延时消息设计与实现&quot;&gt;2 高效延时消息设计与实现&lt;/h2&gt;

&lt;p&gt;高效延时消息，包含两个重要的数据结构：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;环形队列，例如可以创建一个包含3600个slot的环形队列（本质是个数组）&lt;/li&gt;
  &lt;li&gt;任务集合，环上每一个slot是一个Set&lt;Task&gt;&lt;/Task&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同时，启动一个timer，这个timer每隔1s，在上述环形队列中移动一格，有一个curIndex指针来标识正在检测的slot。&lt;/p&gt;

&lt;p&gt;Task结构中有两个很重要的属性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;CycleNum：当curIndex第几圈扫描到这个Slot时，执行任务&lt;/li&gt;
  &lt;li&gt;TaskFunction：需要执行的任务指针&lt;/li&gt;
&lt;/ol&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
    &lt;a href=&quot;https://dyxu.net&quot; title=&quot;延迟消息原理&quot; target=&quot;_blank&quot;&gt;
    
        &lt;img src=&quot;/images/2017/10/delay_message.png&quot; alt=&quot;延迟消息原理&quot; /&gt;
    
    &lt;/a&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;延迟消息原理&lt;/p&gt;
    
&lt;/div&gt;

&lt;p&gt;假设当前curIndex指向第一格，当有延时消息到达之后，例如希望3610秒之后，触发一个延时消息任务，只需：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算这个Task应该放在哪一个slot，现在指向1，3610秒之后，应该是第11格，所以这个Task应该放在第11个slot的Set&lt;Task&gt;中&lt;/Task&gt;&lt;/li&gt;
  &lt;li&gt;计算这个Task的CycleNum，由于环形队列是3600格（每秒移动一格，正好1小时），这个任务是3610秒后执行，所以应该绕3610/3600=1圈之后再执行，于是CycleNum=1&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;curIndex不停的移动，每秒移动到一个新slot，这个slot中对应的Set&lt;Task&gt;，每个Task看CycleNum是不是0：&lt;/Task&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果不是0，说明还需要多移动几圈，将CycleNum减1&lt;/li&gt;
  &lt;li&gt;如果是0，说明马上要执行这个Task了，取出TaskFunciton执行（可以用单独的线程来执行Task），并把这个Task从Set&lt;Task&gt;中删除&lt;/Task&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用了“延时消息”方案之后，“订单48小时后关闭评价”的需求，只需将在订单关闭时，触发一个48小时之后的延时消息即可：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;无需再轮询全部订单，效率高&lt;/li&gt;
  &lt;li&gt;一个订单，任务只执行一次&lt;/li&gt;
  &lt;li&gt;时效性好，精确到秒（控制timer移动频率可以控制精度）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-实现&quot;&gt;3 实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main;
 
import (
    &quot;time&quot;
    &quot;errors&quot;
    &quot;fmt&quot;
)
 
//延迟消息
type DelayMessage struct {
    //当前下标
    curIndex int;
    //环形槽
    slots [3600]map[string]*Task;
    //关闭
    closed chan bool;
    //任务关闭
    taskClose chan bool;
    //时间关闭
    timeClose chan bool;
    //启动时间
    startTime time.Time;
}
 
//执行的任务函数
type TaskFunc func(args ...interface{});
 
//任务
type Task struct {
    //循环次数
    cycleNum int;
    //执行的函数
    exec   TaskFunc;
    params []interface{};
}
 
//创建一个延迟消息
func NewDelayMessage() *DelayMessage {
    dm := &amp;amp;DelayMessage{
        curIndex:  0,
        closed:    make(chan bool),
        taskClose: make(chan bool),
        timeClose: make(chan bool),
        startTime: time.Now(),
    };
    for i := 0; i &amp;lt; 3600; i++ {
        dm.slots[i] = make(map[string]*Task);
    }
    return dm;
}
 
//启动延迟消息
func (dm *DelayMessage) Start() {
    go dm.taskLoop();
    go dm.timeLoop();
    select {
    case &amp;lt;-dm.closed:
        {
            dm.taskClose &amp;lt;- true;
            dm.timeClose &amp;lt;- true;
            break;
        }
    };
}
 
//关闭延迟消息
func (dm *DelayMessage) Close() {
    dm.closed &amp;lt;- true;
}
 
//处理每1秒的任务
func (dm *DelayMessage) taskLoop() {
    defer func() {
        fmt.Println(&quot;taskLoop exit&quot;);
    }();
    for {
        select {
        case &amp;lt;-dm.taskClose:
            {
                return;
            }
        default:
            {
                //取出当前的槽的任务
                tasks := dm.slots[dm.curIndex];
                if len(tasks) &amp;gt; 0 {
                    //遍历任务，判断任务循环次数等于0，则运行任务
                    //否则任务循环次数减1
                    for k, v := range tasks {
                        if v.cycleNum == 0 {
                            go v.exec(v.params...);
                            //删除运行过的任务
                            delete(tasks, k);
                        } else {
                            v.cycleNum--;
                        }
                    }
                }
            }
        }
    }
}
 
//处理每1秒移动下标
func (dm *DelayMessage) timeLoop() {
    defer func() {
        fmt.Println(&quot;timeLoop exit&quot;);
    }();
    tick := time.NewTicker(time.Second);
    for {
        select {
        case &amp;lt;-dm.timeClose:
            {
                return;
            }
        case &amp;lt;-tick.C:
            {
                fmt.Println(time.Now().Format(&quot;2006-01-02 15:04:05&quot;));
                //判断当前下标，如果等于3599则重置为0，否则加1
                if dm.curIndex == 3599 {
                    dm.curIndex = 0;
                } else {
                    dm.curIndex++;
                }
            }
        }
    }
}
 
//添加任务
func (dm *DelayMessage) AddTask(t time.Time, key string, exec TaskFunc, params []interface{}) error {
    if dm.startTime.After(t) {
        return errors.New(&quot;时间错误&quot;);
    }
    //当前时间与指定时间相差秒数
    subSecond := t.Unix() - dm.startTime.Unix();
    //计算循环次数
    cycleNum := int(subSecond / 3600);
    //计算任务所在的slots的下标
    ix := subSecond % 3600;
    //把任务加入tasks中
    tasks := dm.slots[ix];
    if _, ok := tasks[key]; ok {
        return errors.New(&quot;该slots中已存在key为&quot; + key + &quot;的任务&quot;);
    }
    tasks[key] = &amp;amp;Task{
        cycleNum: cycleNum,
        exec:     exec,
        params:   params,
    };
    return nil;
}
 
func main() {
    //创建延迟消息
    dm := NewDelayMessage();
    //添加任务
    dm.AddTask(time.Now().Add(time.Second*10), &quot;test1&quot;, func(args ...interface{}) {
        fmt.Println(args...);
    }, []interface{}{1, 2, 3});
    dm.AddTask(time.Now().Add(time.Second*10), &quot;test2&quot;, func(args ...interface{}) {
        fmt.Println(args...);
    }, []interface{}{4, 5, 6});
    dm.AddTask(time.Now().Add(time.Second*20), &quot;test3&quot;, func(args ...interface{}) {
        fmt.Println(args...);
    }, []interface{}{&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;});
    dm.AddTask(time.Now().Add(time.Second*30), &quot;test4&quot;, func(args ...interface{}) {
        sum := 0;
        for arg := range args {
            sum += arg;
        }
        fmt.Println(&quot;sum : &quot;, sum);
    }, []interface{}{1, 2, 3});
 
    //40秒后关闭
    time.AfterFunc(time.Second*40, func() {
        dm.Close();
    });
    dm.Start();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    <link>https://dyxu.net/%E6%8A%80%E6%9C%AF/delay-message.html</link>
    <guid>https://dyxu.net/%E6%8A%80%E6%9C%AF/delay-message</guid>
    <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>游戏开发学习之路</title>
    <description>
&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
    &lt;a href=&quot;https://dyxu.net&quot; title=&quot;游戏开发学习&quot; target=&quot;_blank&quot;&gt;
    
        &lt;img src=&quot;/images/2017/07/game-programmer-zh-cn.svg&quot; alt=&quot;游戏开发学习&quot; /&gt;
    
    &lt;/a&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;游戏开发学习路线&lt;/p&gt;
    
&lt;/div&gt;

</description>
    <link>https://dyxu.net/%E6%8A%80%E6%9C%AF/game-programer.html</link>
    <guid>https://dyxu.net/%E6%8A%80%E6%9C%AF/game-programer</guid>
    <pubDate>Mon, 31 Jul 2017 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>supervisor进程管理工具</title>
    <description>
&lt;p&gt;&lt;a href=&quot;http://supervisord.org/&quot;&gt;Supervisor&lt;/a&gt;是一款基于客户端、服务端模式的进程管理工具。当然，通过nohup、screen等命令也可以实现Linux程序的后台运行，但是如果服务因为内存泄露等原因导致程序异常退出，上述方案就无能为力了。Supervisor就是这样由Python开发的通用进程管理工具，能够将一个普通进程变为守护进程，并且监控进程状态，异常退出时能够自动重启。&lt;/p&gt;

&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;Supervisor的安装和其他python程序一样，可通过&lt;code&gt;pip install supervisor&lt;/code&gt;命令直接安装。对于没有网络，或者防火墙比较厚的机器需要下载以下两个依赖包：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pypi.python.org/pypi/setuptools&quot;&gt;setuptools&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.plope.com/software/meld3/&quot;&gt;meld3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解压并在目录下分别执行&lt;code&gt;python setup.py install&lt;/code&gt;，最后到supervisor目录，执行&lt;code&gt;python setup.py install&lt;/code&gt;完成安装。&lt;/p&gt;

&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;

&lt;p&gt;Supervisor默认配置文件在&lt;code&gt;/etc/supervisord.conf&lt;/code&gt;，格式及其含义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-conf&quot;&gt;; Sample supervisor config file.

[unix_http_server]
file=/run/supervisor.sock   ; (the path to the socket file)
;chmod=0700                 ; socked file mode (default 0700)
;chown=nobody:nogroup       ; socket file uid:gid owner
;username=user              ; (default is no username (open server))
;password=123               ; (default is no password (open server))

[inet_http_server]         ; inet (TCP) server disabled by default
port=127.0.0.1:9001        ; (ip_address:port specifier, *:port for all iface)
;username=user              ; (default is no username (open server))
;password=123               ; (default is no password (open server))

[supervisord]
logfile=/var/log/supervisord.log ; (main log file;default $CWD/supervisord.log)
;logfile_maxbytes=50MB       ; (max main logfile bytes b4 rotation;default 50MB)
;logfile_backups=10          ; (num of main logfile rotation backups;default 10)
loglevel=info                ; (log level;default info; others: debug,warn,trace)
pidfile=/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)
nodaemon=false               ; (start in foreground if true;default false)
;minfds=1024                 ; (min. avail startup file descriptors;default 1024)
;minprocs=200                ; (min. avail process descriptors;default 200)
;umask=022                   ; (process file creation umask;default 022)
;user=chrism                 ; (default is current user, required if root)
;identifier=supervisor       ; (supervisord identifier, default is 'supervisor')
;directory=/tmp              ; (default is not to cd during start)
;nocleanup=true              ; (don't clean up tempfiles at start;default false)
childlogdir=/var/log/supervisor ; ('AUTO' child log dir, default $TEMP)
;environment=KEY=value       ; (key value pairs to add to environment)
;strip_ansi=false            ; (strip ansi escape codes in logs; def. false)

; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///run/supervisor.sock ; use a unix:// URL  for a unix socket
;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket
;username=chris              ; should be same as http_username if set
;password=123                ; should be same as http_password if set
;prompt=mysupervisor         ; cmd line prompt (default &quot;supervisor&quot;)
;history_file=~/.sc_history  ; use readline history if available

; The below sample program section shows all possible program subsection values,
; create one or more 'real' program: sections to be able to control them under
; supervisor.

;[program:theprogramname]
;command=/bin/cat              ; the program (relative uses PATH, can take args)
;process_name=%(program_name)s ; process_name expr (default %(program_name)s)
;numprocs=1                    ; number of processes copies to start (def 1)
;directory=/tmp                ; directory to cwd to before exec (def no cwd)
;umask=022                     ; umask for process (default None)
;priority=999                  ; the relative start priority (default 999)
;autostart=true                ; start at supervisord start (default: true)
;autorestart=unexpected        ; whether/when to restart (default: unexpected)
;startsecs=1                   ; number of secs prog must stay running (def. 1)
;startretries=3                ; max # of serial start failures (default 3)
;exitcodes=0,2                 ; 'expected' exit codes for process (default 0,2)
;stopsignal=QUIT               ; signal used to kill process (default TERM)
;stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)
;killasgroup=false             ; SIGKILL the UNIX process group (def false)
;user=chrism                   ; setuid to this UNIX account to run the program
;redirect_stderr=true          ; redirect proc stderr to stdout (default false)
;stdout_logfile=/a/path        ; stdout log path, NONE for none; default AUTO
;stdout_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)
;stdout_logfile_backups=10     ; # of stdout logfile backups (default 10)
;stdout_capture_maxbytes=1MB   ; number of bytes in 'capturemode' (default 0)
;stdout_events_enabled=false   ; emit events on stdout writes (default false)
;stderr_logfile=/a/path        ; stderr log path, NONE for none; default AUTO
;stderr_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)
;stderr_logfile_backups=10     ; # of stderr logfile backups (default 10)
;stderr_capture_maxbytes=1MB   ; number of bytes in 'capturemode' (default 0)
;stderr_events_enabled=false   ; emit events on stderr writes (default false)
;environment=A=1,B=2           ; process environment additions (def no adds)
;serverurl=AUTO                ; override serverurl computation (childutils)

; The below sample eventlistener section shows all possible
; eventlistener subsection values, create one or more 'real'
; eventlistener: sections to be able to handle event notifications
; sent by supervisor.

;[eventlistener:theeventlistenername]
;command=/bin/eventlistener    ; the program (relative uses PATH, can take args)
;process_name=%(program_name)s ; process_name expr (default %(program_name)s)
;numprocs=1                    ; number of processes copies to start (def 1)
;events=EVENT                  ; event notif. types to subscribe to (req'd)
;buffer_size=10                ; event buffer queue size (default 10)
;directory=/tmp                ; directory to cwd to before exec (def no cwd)
;umask=022                     ; umask for process (default None)
;priority=-1                   ; the relative start priority (default -1)
;autostart=true                ; start at supervisord start (default: true)
;autorestart=unexpected        ; whether/when to restart (default: unexpected)
;startsecs=1                   ; number of secs prog must stay running (def. 1)
;startretries=3                ; max # of serial start failures (default 3)
;exitcodes=0,2                 ; 'expected' exit codes for process (default 0,2)
;stopsignal=QUIT               ; signal used to kill process (default TERM)
;stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)
;killasgroup=false             ; SIGKILL the UNIX process group (def false)
;user=chrism                   ; setuid to this UNIX account to run the program
;redirect_stderr=true          ; redirect proc stderr to stdout (default false)
;stdout_logfile=/a/path        ; stdout log path, NONE for none; default AUTO
;stdout_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)
;stdout_logfile_backups=10     ; # of stdout logfile backups (default 10)
;stdout_events_enabled=false   ; emit events on stdout writes (default false)
;stderr_logfile=/a/path        ; stderr log path, NONE for none; default AUTO
;stderr_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)
;stderr_logfile_backups        ; # of stderr logfile backups (default 10)
;stderr_events_enabled=false   ; emit events on stderr writes (default false)
;environment=A=1,B=2           ; process environment additions
;serverurl=AUTO                ; override serverurl computation (childutils)

; The below sample group section shows all possible group values,
; create one or more 'real' group: sections to create &quot;heterogeneous&quot;
; process groups.

;[group:thegroupname]
;programs=progname1,progname2  ; each refers to 'x' in [program:x] definitions
;priority=999                  ; the relative start priority (default 999)

; The [include] section can just contain the &quot;files&quot; setting.  This
; setting can list multiple files (separated by whitespace or
; newlines).  It can also contain wildcards.  The filenames are
; interpreted as relative to this file.  Included files *cannot*
; include files themselves.

[include]
files = /etc/supervisor.d/*.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各配置项的含义其实已经很明显了。进程管理的配置可以直接写在配置文件supervisord.conf中，也可以分进程保存在指定目录下，在include中导入，推荐后者。配置格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-conf&quot;&gt;[program:mydeamon]
directory = /usr/local/mydeamon/ ; 程序的启动目录
command = /usr/local/mydeamon/bin/mydeamon ; 启动命令，与手动在命令行启动的命令是一样的
autostart = true     ; 在 supervisord 启动的时候是否自动启动
startsecs = 10        ; 启动10秒后没有异常退出，就当作已经正常启动了
autorestart = unexpected   ; 程序异常退出后自动重启
exitcodes = 0 ; 返回码为0时，正常退出，否则自动重启
startretries = 3     ; 启动失败自动重试次数，默认是 3
user = root          ; 用哪个用户启动
redirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false
stdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB
stdout_logfile_backups = 20     ; stdout 日志文件备份数
; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）
stdout_logfile = /var/log/mydeamon_stdout.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将上述文件命名为mydeamon.init保存在&lt;code&gt;/etc/supervisor.d&lt;/code&gt;目录下即可。&lt;/p&gt;

&lt;h2 id=&quot;管理命令&quot;&gt;管理命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;supervisord # 初始启动Supervisord，启动、管理配置中设置的进程。
supervisorctl stop xxx # 停止某一个进程(xxx)，xxx为[program:mydeamon]里配置的值，这个示例就是mydeamon。
supervisorctl start xxx # 启动某个进程
supervisorctl restart xxx # 重启某个进程
supervisorctl stop all # 停止全部进程，注：start、restart、stop都不会载入最新的配置文件。
supervisorctl reload # 载入最新的配置文件，并按新的配置启动、管理所有进程。
&lt;/code&gt;&lt;/pre&gt;
</description>
    <link>https://dyxu.net/%E5%B7%A5%E5%85%B7/supervisor.html</link>
    <guid>https://dyxu.net/%E5%B7%A5%E5%85%B7/supervisor</guid>
    <pubDate>Wed, 26 Jul 2017 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>关系型数据库设计【转载】</title>
    <description>
&lt;p&gt;&lt;strong&gt;本文转载自&lt;a href=&quot;http://www.cnblogs.com/MeteorSeed/archive/2013/03/27/2880054.html&quot;&gt;博客&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据库设计，一个软件项目成功的基石。很多从业人员都认为，数据库设计其实不那么重要。现实中的情景也相当雷同，开发人员的数量是数据库设计人员的数倍。多数人使用数据库中的一部分，所以也会把数据库设计想的如此简单。其实不然，数据库设计也是门学问。&lt;/p&gt;

&lt;p&gt;　　从笔者的经历看来，笔者更赞成在项目早期由开发者进行数据库设计（后期调优需要DBA）。根据笔者的项目经验，一个精通OOP和ORM的开发者，设计的数据库往往更为合理，更能适应需求的变化，如果追其原因，笔者个人猜测是因为数据库的规范化，与OO的部分思想雷同（如内聚）。而DBA，设计的数据库的优势是能将DBMS的能力发挥到极致，能够使用SQL和DBMS实现很多程序实现的逻辑，与开发者相比，DBA优化过的数据库更为高效和稳定。如标题所示，本文旨在分享一名开发者的数据库设计经验，并不涉及复杂的SQL语句或DBMS使用，因此也不会局限到某种DBMS产品上。真切地希望这篇文章对开发者能有所帮助，也希望读者能帮助笔者查漏补缺。&lt;/p&gt;

&lt;h2 id=&quot;1-codd的rdbms12法则rdbms的起源&quot;&gt;1 Codd的RDBMS12法则——RDBMS的起源&lt;/h2&gt;
&lt;p&gt;Edgar Frank Codd（埃德加·弗兰克·科德）被誉为“关系数据库之父”，并因为在数据库管理系统的理论和实践方面的杰出贡献于1981年获图灵奖。在1985年，Codd 博士发布了12条规则，这些规则简明的定义出一个关系型数据库的理念，它们被作为所有关系数据库系统的设计指导性方针。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;信息法则 关系数据库中的所有信息都用唯一的一种方式表示——表中的值。&lt;/li&gt;
  &lt;li&gt;保证访问法则 依靠表名、主键值和列名的组合，保证能访问每个数据项。&lt;/li&gt;
  &lt;li&gt;空值的系统化处理 支持空值（NULL），以系统化的方式处理空值，空值不依赖于数据类型。&lt;/li&gt;
  &lt;li&gt;基于关系模型的动态联机目录 数据库的描述应该是自描述的，在逻辑级别上和普通数据采用同样的表示方式，即数据库必须含有描述该数据库结构的系统表或者数据库描述信息应该包含在用户可以访问的表中。&lt;/li&gt;
  &lt;li&gt;统一的数据子语言法则 一个关系数据库系统可以支持几种语言和多种终端使用方式，但必须至少有一种语言，它的语句能够一某种定义良好的语法表示为字符串，并能全面地支持以下所有规则：数据定义、视图定义、数据操作、约束、授权以及事务。（这种语言就是SQL)&lt;/li&gt;
  &lt;li&gt;视图更新法则 所有理论上可以更新的视图也可以由系统更新。&lt;/li&gt;
  &lt;li&gt;高级的插入、更新和删除操作 把一个基础关系或派生关系作为单个操作对象处理的能力不仅适应于数据的检索，还适用于数据的插入、修改个删除，即在插入、修改和删除操作中数据行被视作集合。&lt;/li&gt;
  &lt;li&gt;数据的物理独立性 不管数据库的数据在存储表示或访问方式上怎么变化，应用程序和终端活动都保持着逻辑上的不变性。&lt;/li&gt;
  &lt;li&gt;数据的逻辑独立性 当对表做了理论上不会损害信息的改变时，应用程序和终端活动都会保持逻辑上的不变性。&lt;/li&gt;
  &lt;li&gt;数据完整性的独立性 专用于某个关系型数据库的完整性约束必须可以用关系数据库子语言定义，而且可以存储在数据目录中，而非程序中。&lt;/li&gt;
  &lt;li&gt;分布独立性 不管数据在物理是否分布式存储，或者任何时候改变分布策略，RDBMS的数据操纵子语言必须能使应用程序和终端活动保持逻辑上的不变性。&lt;/li&gt;
  &lt;li&gt;非破坏性法则 如果一个关系数据库系统支持某种低级（一次处理单个记录）语言，那么这个低级语言不能违反或绕过更高级语言（一次处理多个记录）规定的完整性法则或约束，即用户不能以任何方式违反数据库的约束。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-关系型数据库设计阶段&quot;&gt;2 关系型数据库设计阶段&lt;/h2&gt;

&lt;h3 id=&quot;21-规划阶段&quot;&gt;2.1 规划阶段&lt;/h3&gt;

&lt;p&gt;规划阶段的主要工作是对数据库的必要性和可行性进行分析。确定是否需要使用数据库，使用哪种类型的数据库，使用哪个数据库产品。&lt;/p&gt;

&lt;h3 id=&quot;22-概念阶段&quot;&gt;2.2 概念阶段&lt;/h3&gt;

&lt;p&gt;概念阶段的主要工作是收集并分析需求。识别需求，主要是识别数据实体和业务规则。对于一个系统来说，数据库的主要包括业务数据和非业务数据，而业务数据的定义，则依赖于在此阶段对用户需求的分析。需要尽量识别业务实体和业务规则，对系统的整体有初步的认识，并理解数据的流动过程。理论上，该阶段将参考或产出多种文档，比如“用例图”，“数据流图”以及其他一些项目文档。如果能够在该阶段产出这些成果，无疑将会对后期进行莫大的帮助。当然，很多文档已超出数据库设计者的考虑范围。而且，如果你并不精通该领域以及用户的业务，那么请放弃自己独立完成用户需求分析的想法。用户并不是技术专家，而当你自身不能扮演“业务顾问”的角色时，请你选择与项目组的相关人员合作，或者将其视为风险呈报给PM。再次强调，大多数情况，用户只是行业从业者，而非职业技术人员，我们仅仅从用户那里收集需求，而非依赖于用户的知识。&lt;/p&gt;

&lt;p&gt;记录用户需求时，可以使用一些技巧，当然这部分内容有些可能会超出数据库设计人员的职责：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;努力维护一系列包含了系统设计和规格说明信息的文档，如会议记录、访谈记录、关键用户期望、功能规格、技术规格、测试规格等。&lt;/li&gt;
  &lt;li&gt;频繁与干系人沟通并收集反馈。&lt;/li&gt;
  &lt;li&gt;标记出你自己添加的，不属于客户要求的，未决内容。&lt;/li&gt;
  &lt;li&gt;与所有关键干系人尽快确认项目范围，并力求冻结需求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，必须严谨处理业务规则，并详细记录。在之后的阶段，将会根据这些业务规则进行设计。当该阶段结束时，你应该能够回答以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要哪些数据？&lt;/li&gt;
  &lt;li&gt;数据该被怎样使用？&lt;/li&gt;
  &lt;li&gt;哪些规则控制着数据的使用？&lt;/li&gt;
  &lt;li&gt;谁会使用何种数据？&lt;/li&gt;
  &lt;li&gt;客户想在核心功能界面或者报表上看到哪些内容？&lt;/li&gt;
  &lt;li&gt;数据现在在哪里？&lt;/li&gt;
  &lt;li&gt;数据是否与其他系统有交互、集成或同步？&lt;/li&gt;
  &lt;li&gt;主题数据有哪些？&lt;/li&gt;
  &lt;li&gt;核心数据价值几何，对可靠性的要求程度？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并且得到如下信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实体和关系&lt;/li&gt;
  &lt;li&gt;属性和域&lt;/li&gt;
  &lt;li&gt;可以在数据库中强制执行的业务规则&lt;/li&gt;
  &lt;li&gt;需要使用数据库的业务过程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;23-逻辑阶段&quot;&gt;2.3 逻辑阶段&lt;/h3&gt;

&lt;p&gt;逻辑阶段的主要工作是绘制E-R图，或者说是建模。建模工具很多，有不同的图形表示方法和软件。这些工具和软件的使用并非关键，笔者也不建议读者花大量时间在建模方法的选择上。对于大多数应用来说，E-R图足以描述实体间的关系。建模关键是思想而不是工具，软件只是起到辅助作用，识别实体关系才是本阶段的重点。&lt;/p&gt;

&lt;p&gt;除了实体关系，我们还应该考虑属性的域（值类型、范围、约束）&lt;/p&gt;

&lt;h3 id=&quot;24-实现阶段&quot;&gt;2.4 实现阶段&lt;/h3&gt;

&lt;p&gt;实现阶段主要针对选择的RDBMS定义E-R图对应的表，考虑属性类型和范围以及约束。&lt;/p&gt;

&lt;h3 id=&quot;25-物理阶段&quot;&gt;2.5 物理阶段&lt;/h3&gt;

&lt;p&gt;物理阶段是一个验证并调优的阶段，是在实际物理设备上部署数据库，并进行测试和调优。&lt;/p&gt;

&lt;h2 id=&quot;3-计原则&quot;&gt;3 计原则&lt;/h2&gt;

&lt;h3 id=&quot;31-降低对数据库功能的依赖&quot;&gt;3.1 降低对数据库功能的依赖&lt;/h3&gt;

&lt;p&gt;功能应该由程序实现，而非DB实现。原因在于，如果功能由DB实现时，一旦更换的DBMS不如之前的系统强大，不能实现某些功能，这时我们将不得不去修改代码。所以，为了杜绝此类情况的发生，功能应该有程序实现，数据库仅仅负责数据的存储，以达到最低的耦合。&lt;/p&gt;

&lt;h3 id=&quot;32-定义实体关系的原则&quot;&gt;3.2 定义实体关系的原则&lt;/h3&gt;

&lt;p&gt;当定义一个实体与其他实体之间的关系时，需要考量如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;牵涉到的实体 识别出关系所涉及的所有实体。&lt;/li&gt;
  &lt;li&gt;所有权 考虑一个实体“拥有”另一个实体的情况。&lt;/li&gt;
  &lt;li&gt;基数 考量一个实体的实例和另一个实体实例关联的数量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关系与表数量&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;描述1:1关系最少需要1张表。&lt;/li&gt;
  &lt;li&gt;描述1:n关系最少需要2张表。&lt;/li&gt;
  &lt;li&gt;描述n:n关系最少需要3张表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;33-列意味着唯一的值&quot;&gt;3.3 列意味着唯一的值&lt;/h3&gt;

&lt;h3 id=&quot;34-列的顺序&quot;&gt;3.4 列的顺序&lt;/h3&gt;

&lt;p&gt;列的顺序对于表来说无关紧要，但是从习惯上来说，采用“主键+外键+实体数据+非实体数据”这样的顺序对列进行排序显然能得到比较好的可读性。&lt;/p&gt;

&lt;h3 id=&quot;35-定义主键和外键&quot;&gt;3.5 定义主键和外键&lt;/h3&gt;

&lt;p&gt;数据表必须定义主键和外键（如果有外键）。定义主键和外键不仅是RDBMS的要求，同时也是开发的要求。几乎所有的代码生成器都需要这些信息来生成常用方法的代码（包括SQL文和引用），所以，定义主键和外键在开发阶段是必须的。之所以说在开发阶段是必须的是因为，有不少团队出于性能考虑会在进行大量测试后，在保证参照完整性不会出现大的缺陷后，会删除掉DB的所有外键，以达到最优性能。笔者认为，在性能没有出现问题时应该保留外键，而即便性能真的出现问题，也应该对SQL文进行优化，而非放弃外键约束。&lt;/p&gt;

&lt;h3 id=&quot;36-选择键&quot;&gt;3.6 选择键&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;人工键与自然键&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;人工健——实体的非自然属性，根据需要由人强加的，如GUID，其对实体毫无意义；自然健——实体的自然属性，如身份证编号。&lt;/p&gt;

&lt;p&gt;人工键的好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;键值永远不变&lt;/li&gt;
  &lt;li&gt;永远是单列存储&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;人工键的缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为人工键是没有实际意义的唯一值，所以不能通过人工键来避免重复行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;笔者建议全部使用人工键。原因如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在设计阶段我们无法预测到代码真正需要的值，所以干脆放弃猜测键，而使用人工键。&lt;/li&gt;
  &lt;li&gt;人工键复杂处理实体关系，而不负责任何属性描述，这样的设计使得实体关系与实体内容得到高度解耦，这样做的设计思路更加清晰。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;笔者的另一个建议是——每张表都需要有一个对用户而言有意义的自然键，在特殊情况下也许找不到这样一个项，此时可以使用复合键。这个键我在程序中并不会使用其作为唯一标识，但是却可以在对数据库直接进行查询时使用。&lt;/p&gt;

&lt;p&gt;使用人工键的另一根弊端，主要源自对查询性能的考量，因此选择人工键的形式（列的类型）很重要：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自增值类型 由于类型轻巧查询效率更好，但取值有限。&lt;/li&gt;
  &lt;li&gt;GUID 查询效率不如值类型，但是取值无限，且对开发人员更加亲切。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;智能健与非智能键&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;智能键——键值包含额外信息，其根据某种约定好的编码规范进行编码，从键值本身可以获取某些信息；非智能键，单纯的无意义键值，如自增的数字或GUID。&lt;/p&gt;

&lt;p&gt;智能键是一把双刃剑，开发人员偏爱这种包含信息的键值，程序盼望着其中潜在的数据；数据库管理员或者设计者则讨厌这种智能键，原因也是很显然的，智能键对数据库是潜在的风险。前面提到，数据库设计的原则之一是不要把具有独立意义的值的组合实现到一个单一的列中，应该使用多个独立的列。数据库设计者，更希望开发人员通过拼接多个列来得到智能键，即以复合主键的形式给开发人员使用，而不是将一个列的值分解后使用。开发人员应该接受这种数据库设计，但是很多开发者却想不明白两者的优略。笔者认为，使用单一列实现智能键存在这样一个风险，就是我们可能在设计阶段无法预期到编码规则可能会在后期发生变化。比如，构成智能键的局部键的值用完而引起规则变化或者长度变化，这种编码规则的变化对于程序的有效性验证与智能键解析是破坏性的，这是系统运维人员最不希望看到的。所以笔者建议如果需要智能键，请在业务逻辑层封装（使用只读属性），不要再持久化层实现，以避免上述问题。&lt;/p&gt;

&lt;h3 id=&quot;37-是否允许null&quot;&gt;3.7 是否允许NULL&lt;/h3&gt;

&lt;p&gt;关于NULL我们需要了解它的几个特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任何值和NULL拼接后都为NULL。&lt;/li&gt;
  &lt;li&gt;所有与NULL进行的数学操作都返回NULL。&lt;/li&gt;
  &lt;li&gt;引入NULL后，逻辑不易处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么我们是否应该允许列为空呢？笔者认为这个问题的答案受到我们的开发语言的影响。以C#为例，因为引入了可空类型来处理数据库值类型为NULL的情形，所以是否允许为空对开发者来说意义并不大。但有一点必须注意，就是验证非空必须要在程序集进行处理，而不该依赖于DBMS的非空约束，必须确保完整数据（所有必须的属性均被赋值）到达DB（所谓的“安全区”，我们必须定义在多层系统中那些区域得到的数据是安全而纯净的）&lt;/p&gt;

&lt;h3 id=&quot;38-属性切割&quot;&gt;3.8 属性切割&lt;/h3&gt;

&lt;p&gt;一种错误想法是，属性与列是1：1的关系。对于开发者，我们公开属性而非字段。举个例子来说，对于实体“员工”有“名字”这一属性，“名字”可以再被分解为“姓”和“名”，对于开发人员来说，显然第二种数据结构更受青睐（“姓”和“名”作为两个字段）。所以，在设计时我们也应该根据需要考虑是否切割属性。&lt;/p&gt;

&lt;h3 id=&quot;39-规范化范式&quot;&gt;3.9 规范化——范式&lt;/h3&gt;

&lt;p&gt;当笔者还在大学时，范式是学习关系型数据库时最头疼的问题。我想也许会有读者仍然不理解范式的价值，简单来说——范式将帮助我们来保证数据的有效性和完整性。规范化的目的如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;消灭重复数据。&lt;/li&gt;
  &lt;li&gt;避免编写不必要的，用来使重复数据同步的代码。&lt;/li&gt;
  &lt;li&gt;保持表的瘦身，以及减从一张表中读取数据时需要进行的读操作数量。&lt;/li&gt;
  &lt;li&gt;最大化聚集索引的使用，从而可以进行更优化的数据访问和联结。&lt;/li&gt;
  &lt;li&gt;减少每张表使用的索引数量，因为维护索引的成本很高。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;规范化旨在——挑出复杂的实体，从中抽取出简单的实体。这个过程一直持续下去，直到数据库中每个表都只代表一件事物，并且表中每个描述的都是这件事物为止。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;规范化实体和属性（去除冗余）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;1NF：每个属性都只应表示一个单一的值，而非多个值。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需要考虑几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;属性是原子性的&lt;/strong&gt; 需要考虑熟悉是否分解的足够彻底，使得每个属性都表示一个单一的值。（和“（三）列意味着唯一的值”描述的原则相同。）分解原则为——当你需要分开处理每个部分时才分解值，并且分解到足够用就行。（即使当前不需要彻底分解属性，也应该考虑未来可能的需求变更。）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;属性的所有实例必须包含相同数量的值&lt;/strong&gt; 实体有固定数量的属性（表有固定数量的列）。设计实体时，要让每个属性只有固定数量的值与其相关联。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实体中出现的所有实体类型都必须不同&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前设计不符合1NF的“臭味”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;包含分隔符类字符的字符串数据。&lt;/li&gt;
  &lt;li&gt;名字尾端有数字的属性。&lt;/li&gt;
  &lt;li&gt;没有定义键或键定义不好的表。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;属性间的关系（去除冗余）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;2NF-实体必须符合1NF，每个属性描述的东西都必须针对整个键（可以理解为oop中类型属性的内聚性）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当前设计不符合2NF的“臭味”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;重复的键属性名字前缀（设计之外的数据冗余）&lt;/strong&gt; 表明这些值可能描述了某些额外的实体。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;有重复的数据组（设计之外的数据冗余）&lt;/strong&gt; 这标志着属性间有函数依赖型。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;没有外键的复合主键&lt;/strong&gt; 这标志着键中的键值可能标识了多种事物，而不是一种事物。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3NF-实体必须符合2NF，非键属性不能描述其他非键属性。（与2NF不同，3NF处理的是非键属性和非键属性之间的关系，而不是和键属性之间的关系。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当前设计不符合3NF的“臭味”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多个属性有同样的前缀。&lt;/li&gt;
  &lt;li&gt;重复的数据组。&lt;/li&gt;
  &lt;li&gt;汇总的数据，所引用的数据在一个完全不同的实体中。（有些人倾向于使用视图，我更倾向于使用对象集合，即由程序来完成。）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;BCNF-实体满足第一范式，所有属性完全依赖于某个键，如果所有的判定都是一个键，则实体满足BCNF。（BCNF简单地扩展了以前的范式，它说的是：一个实体可能有若干个键，所有属性都必须依赖于这些键中的一个，也可以理解为“每个键必须唯一标识实体，每个非键熟悉必须描述实体。”&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;去除实体组合键中的冗余&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;4NF-实体必须满足BCNF，在一个属性与实体的键之间，多值依赖（一条记录在整个表的唯一性由多个值组合起来决定的）不能超过一个。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当前设计不符合4NF的“臭味”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;三元关系（实体:实体:实体）。&lt;/li&gt;
  &lt;li&gt;潜伏的多值属性。（如多个手机号。）&lt;/li&gt;
  &lt;li&gt;临时数据或历史值。（需要将历史数据的主体提出，否则将存在大量冗余。）&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;尽量将所有关系分解为二元关系　&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;5NF-实体必须满足4NF，当分解的信息无损的时候，确保所有关系都被分解为二元关系。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;5NF保证在第四范式中存在的任何可以分解为实体的三元关系都被分解。有的三元关系可以在不丢失信息的前提下被分解为二元关系，当分解为两个二元关系的过程要丢失信息时，关系被宣称为处于第四范式中。所以，第五范式建议是，最好把现有的三元关系都分解为3个二元关系。&lt;/p&gt;

&lt;p&gt;需要注意的是，规范化的结果可能是更多的表，更复杂的查询。因此，处理到何种程度，取决于性能和数据架构的多方考量。建议规范化到第四范式，原因是5NF的判断太过隐晦。例如：表X（老师，学生，课程）是一个三元关系，可以分解为表A（老师，学生），表B（学生，课程），表C（老师，课程）。表X表示某个老师是上某个学生的某个课程的老师；表A表示老师教学生；表B表示学生上课；表C表示老师教课。单独看是无法发现问题的，但是从数据出发，”表X=表A+表B+表C”并不一定成立，即不能通过连接构建分解前的数据。因为可能有多种组合，丧失了表X反馈出的业务规则。这种现象，容易在设计阶段被忽略，但好在在开放阶段会被显现，而且并不经常发生。&lt;/p&gt;

&lt;p&gt;推荐做法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尽可能地遵守上述规范化原则。&lt;/li&gt;
  &lt;li&gt;所有属性描述的都应该是体现被建模实体的本质的内容。&lt;/li&gt;
  &lt;li&gt;至少必须有一个键，它唯一地标识和描述了所建实体的本质。&lt;/li&gt;
  &lt;li&gt;主键要谨慎选择。&lt;/li&gt;
  &lt;li&gt;在逻辑阶段能做多少规范化就做多少（性能不是逻辑阶段考虑的范畴）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;310-选择数据类型&quot;&gt;3.10 选择数据类型&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;精确数字&lt;/td&gt;
      &lt;td&gt;不会发生精度损失&lt;/td&gt;
      &lt;td&gt;bit tinyint smallint int bigint decimal&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;近似数字&lt;/td&gt;
      &lt;td&gt;对于极值可能发生精度损失&lt;/td&gt;
      &lt;td&gt;float(N) real&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;日期和时间&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;date time smalldatetime datetime datetime2 datetimeoffset&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;二进制数据&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;bingary(N) varbinary(N) varbinary(max)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;字符（串）数据&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;char(N) varchar(N) varchar(max) nchar(N) nvarchar(N) nvarchar(max)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;存储任意数据&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;sql_variant&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;时间戳&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;timestamp&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GUID&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;uniqueidentifier&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XML&lt;/td&gt;
      &lt;td&gt;不要试图使用该类型规避1NF&lt;/td&gt;
      &lt;td&gt;xml&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;空间数据&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;geometry&lt;/td&gt;
      &lt;td&gt;geography&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;层次数据&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;heirarchyid&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;常用类型选择：类型选择的最基本规则是选择满足需要的最轻的类型，因为这样查询更快&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;bool&lt;/td&gt;
      &lt;td&gt;建议使用bit而非char(1)，因为开发语言对其支持觉好，可以直接映射为bool或bool?。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;大值数据&lt;/td&gt;
      &lt;td&gt;使用所有备选类型中最小的那种，类型越大，查询越慢，当字节大于8000时，应使用max。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;主键&lt;/td&gt;
      &lt;td&gt;自增主键根据预期范围选择int或bigint，GUID使用uniqueidentifier而非varchar(N)。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;4-命名规则&quot;&gt;4 命名规则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;表&lt;/strong&gt; “模块名_表名”。表名最好不要用复数，原因是在使用ORM框架开发时，代码生成器根据DB生成类定义，表生成了某个实例的类型定义，而不是实例集合。表名不要太长。原因之一，某些软件对表名最大长度有限制；原因之二，使用代码生成器往往会根据表名生产类型名称，之后懒人会直接使用这一名称，如果将太长的名称跨网络边界显然不是明智之举。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;字段&lt;/strong&gt; bool类型用“Is”、“Can”、“Has”等表示；日期类型命名必须包含“Date”；时间类型必须包含“Time”。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;存储过程&lt;/strong&gt; 使用“proc_”前缀。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;视图&lt;/strong&gt; 使用“view_”前缀。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;触发器&lt;/strong&gt; 使用“trig_”前缀。&lt;/li&gt;
&lt;/ul&gt;
</description>
    <link>https://dyxu.net/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/database-design.html</link>
    <guid>https://dyxu.net/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/database-design</guid>
    <pubDate>Thu, 20 Jul 2017 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>Go性能优化【转载】</title>
    <description>
&lt;p&gt;&lt;strong&gt;本文转载自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27800985?utm_source=tuicool&amp;amp;utm_medium=referral&quot;&gt;知乎专栏&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go的性能优化其实总的来说和C／C++等这些都差不多，但也有它自己独有的排查方法和陷阱，这些都来源于它的语言特性和环境。&lt;/p&gt;

&lt;h2 id=&quot;性能优化前提任何好的东西都是在正确的前提上&quot;&gt;性能优化前提——任何好的东西都是在正确的前提上&lt;/h2&gt;

&lt;p&gt;代码界的很多事是和我们生活的哲学息息相关的，我们想要做好一件事，首先要保证我们能按时完成我们的任务，其次再去想如何把工作做的更好。如果一味只去要求做的尽善尽美可能会导致延期，失败，半途而废。&lt;/p&gt;

&lt;p&gt;所以，先写正确的代码，再去考虑如何去让代码更快更好的运行；先完成基本的功能，再去想如何优化它。正确是优化的基础，没有这个基础，任何的优化都是毫无意义的。&lt;/p&gt;

&lt;h2 id=&quot;性能优化限制架构设计和硬件资源&quot;&gt;性能优化限制——架构设计和硬件资源&lt;/h2&gt;

&lt;p&gt;良好的架构设计是我们能够发挥性能的前提，一个设计不当的架构付出再多精力优化效果也是大打折扣。这也是我们为什么经常会看到随着业务量或者用户数的增加后天架构会不断演进变化，如果说一开始设计的架构可以一直支撑下去，那么请大神请收下我的膝盖！&lt;/p&gt;

&lt;p&gt;硬件资源更好理解，一个16核，64G内存的服务器和4核，4G内存的垃圾机器对比简直是天与地。毋庸多说。&lt;/p&gt;

&lt;h2 id=&quot;什么时候做性能优化&quot;&gt;什么时候做性能优化&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;We should forget about small efficiencies, say about 97% of the time; premature optimization is the root of all evil(大概97％的时间，我们应该忘记小的优化， 过早优化是所有邪恶的根源). —— Donald E.Knuth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这句话不是说不去优化，不去思考算法，而是在早期我们应该更加专注于程序的实现，而不是一开始就去想着优化，你大可以放开去写。慢慢的会有驱动力让我们不自觉去优化。&lt;/p&gt;

&lt;p&gt;正常情况下这种驱动我觉得有两种，一种是自我驱动，比如经历过搞过ACM或者算法竞赛的童鞋们在面对一个问题时会不自觉地从复杂度角度分析问题；或者一个“强迫症患者”不能忍受慢，卡，崩等等情况。&lt;/p&gt;

&lt;p&gt;另一种是环境驱动，比如高并发环境，高精度环境，低延迟环境，大数据环境等等对于我们系统的某一方面甚至多个方面都有苛刻的要求，逼这着我们需要不断优(jia)化(ban)，优(jia)化(ban)，再优(jia)化(ban)。&lt;/p&gt;

&lt;p&gt;当你意识到这个函数可能会被经常调用，就需要想办法的优化
当你意识到这个数据结构设计不合理导致内存占用过高，就需要想办法优化
当用户反映服务响应太慢，就需要优化
当老板既要好的服务又不想再花钱买机器，就需要优化
当代码太乱，问题百出，经常报警告打扰和女票玩耍，就需要优化&lt;/p&gt;

&lt;h2 id=&quot;花多长时间来做性能优化&quot;&gt;花多长时间来做性能优化&lt;/h2&gt;

&lt;p&gt;有人说是二八定律，又名80/20定律、帕累托法则（定律）也叫巴莱特定律、最省力的法则、不平衡原则等，被广泛应用于社会学及企业管理学等。是19世纪末20世纪初意大利经济学家巴莱多发现的。他认为，在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的，因此又称二八定律。—— 百度百科&lt;/p&gt;

&lt;p&gt;我觉得虽然我们不必一定按照二比八的要求去执行，但毫无疑问的是优化会耗费我们非常多的时间和精力，并且远远大于我们系统实现的时间，或者说自从第一次开发完，以后所有的时间都是在做优化。自己的曾经的经历，当时为了给某银行做60W终端测试优化一个API缓存系统，基本功能实现两周就完成了，后面我和性能QA童鞋一波波优化——测试——优化——测试，花费了一个多月时间做这件事，这还没完，后面在真实环境测试过程仍然暴露了很多问题，例如goruntine暴增积压，CPU暴增等等，后来发现是架构设计和组件使用上的问题，是的，当出现这样的问题时不是不可以解决，但是为了解决这样的问题会把系统搞的复杂，臃肿，虽然开发经验不多，但我觉得该是代码实现的代码实现，该是组件解决的问题就应该组件来解决，架构设计问题就是架构需要改进，不要说都可以在代码中解决，除非是不得已。&lt;/p&gt;

&lt;h2 id=&quot;工欲善其事必先利其器&quot;&gt;工欲善其事，必先利其器&lt;/h2&gt;

&lt;p&gt;首先是代码层次，好的代码是性能的关键因素，实现函数效率怎么样，排序是不是高效，操作并发性高不高等等，你可以使用代码质量评估工具来做评估，当然最好还是让有经验的司机们手把手指导。&lt;/p&gt;

&lt;p&gt;Go代码评估工具：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;goreporter – 生成Go代码质量评估报告&lt;/li&gt;
  &lt;li&gt;dingo-hunter – 用于在Go程序中找出deadlocks的静态分析器&lt;/li&gt;
  &lt;li&gt;flen – 在Go程序包中获取函数长度信息&lt;/li&gt;
  &lt;li&gt;go/ast – Package ast声明了关于Go程序包用于表示语法树的类型&lt;/li&gt;
  &lt;li&gt;gocyclo – 在Go源代码中测算cyclomatic函数复杂性&lt;/li&gt;
  &lt;li&gt;Go Meta Linter – 同时Go lint工具且工具的输出标准化&lt;/li&gt;
  &lt;li&gt;go vet – 检测Go源代码并报告可疑的构造&lt;/li&gt;
  &lt;li&gt;ineffassign – 在Go代码中检测无效赋值&lt;/li&gt;
  &lt;li&gt;safesql – Golang静态分析工具，防止SQL注入&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后是如何在运行过程来调试Go程序，Go自带了一个pprof工具，这个工具可以做CPU和内存的profiling。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main
import
   (
    &quot;log&quot;
    &quot;net/http&quot;
   _&quot;net/http/pprof&quot;
   )
func main()  {
      go func() {
        //port is you coustom define.
        log.Println(http.ListenAndServe(&quot;localhost:7000&quot;, nil))
      }()
      //do your stuff.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只需要引入net/http 和 _“net/http/pprof”即可，然后配合工具生成流程图，占比图清晰明了。&lt;/p&gt;

&lt;p&gt;或者对于一些程序你还可以在运行时去改变它，调试它，使用google/gops 谷歌出品，你可以去查看栈，内存，CPU，heap等等信息，很不错，但是我不喜欢它开启了服务端口，这个项目刚开始是不需要使用新的端口，直接使用套接字文件通信，但是因为无法在windows上实现，最后作罢，从此好感降低了！&lt;/p&gt;

&lt;p&gt;当然你还可以使用GDB工具，最新的GDB貌似还加入了查看goruntine的命令，很棒！&lt;/p&gt;

&lt;h2 id=&quot;算法与优化思路&quot;&gt;算法与优化思路&lt;/h2&gt;

&lt;p&gt;这个不用多说，说实话个人觉得算法是区分工程师和码农的一个很大分界点，算法可以说是基本能力，很多人不以为然觉得只是面试门槛，但是看看代码实现中数据结构的设计和算法实现就明白了！当遇到问题会不自觉的想到一个算法，这个目的就够了，其实并没有说算法非常牛逼，其实之前老司机聊天也说过只要你能在遇到问题能够想到用什么算法解决即可。&lt;/p&gt;

&lt;p&gt;各种排序，集合操作，查询等等，没有最好的算法，只要最适合的算法。&lt;/p&gt;

&lt;p&gt;至于哪些方面需要优化，一方面是算法的效率还要就是现象，例如CPU特别高那么看看goruntine的调度，哪个函数占用比高，是不是存在死循环；内存大，看看是不是有大的内存分配没有及时回收，或者是不是有频繁的内存分配，是不是有内存泄露？响应慢是卡在哪里，是执行效率还是和组件通信等等。&lt;/p&gt;

&lt;h2 id=&quot;go的陷阱与技巧&quot;&gt;Go的陷阱与技巧&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;make的陷阱&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func main() {
	s := make([]int, 3)
	s = append(s, 1, 2, 3)
	fmt.Println(s)
}
// [0 0 0 1 2 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;map读写冲突，产生竞态&lt;/li&gt;
  &lt;li&gt;文件打开，数据库连接记得一定要关闭或释放，一般使用defer&lt;/li&gt;
  &lt;li&gt;对于一个struct值的map，你无法更新单个的struct值&lt;/li&gt;
  &lt;li&gt;简化range&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for range m {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;defer的陷阱&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有名返回值则是在函数声明的同时就已经被声明，匿名返回值是在return执行时被声明，所以在defer语句中只能访问有名返回值，而不能直接访问匿名返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;fmt&quot;
)

func main() {
	fmt.Println(&quot;return:&quot;, defer_call())
}

func defer_call() int {
	var i int
	defer func() {
		i++
		fmt.Println(&quot;defer1:&quot;, i)
	}()
	defer func() {
		i++
		fmt.Println(&quot;defer2:&quot;, i)
	}()
	return i
}

// defer2: 1
// defer1: 2
// return: 0
// Q2.

package main

import (
	&quot;fmt&quot;
)

func main() {
	fmt.Println(&quot;return:&quot;, defer_call())
}

func defer_call() (i int) {
	defer func() {
		i++
		fmt.Println(&quot;defer1:&quot;, i)
	}()
	defer func() {
		i++
		fmt.Println(&quot;defer2:&quot;, i)
	}()
	return i
}

// defer2: 1
// defer1: 2
// return: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;短式变量声明的陷阱&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那些使用过动态语言的开发者而言对于短式变量声明的语法很熟悉，所以很容易让人把它当成一个正常的分配操作。这个错误，将不会出现编译错误，但将不会达到你预期的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main
import &quot;fmt&quot;
func main() {  
    value := 1
    fmt.Println(value)     // prints 1
    {
        fmt.Println(value) // prints 1
        value := 2
        fmt.Println(value) // prints 2
    }
    fmt.Println(value)     // prints 1 (bad if you need 2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个说到底是代码边界和变量影响范围问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;nil和显式类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nil标志符用于表示interface、函数、maps、slices和channels的“零值”。如果你不指定变量的类型，编译器将无法编译你的代码，因为它不知道具体的类型，同时你也不能给string赋nil值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

func main() {
    var value1 = nil // error
    _ = value1
    var value2 string = nil // error
    if value2 == nil { // error
        value2 = &quot;test&quot;
    }
}
// 应该
package main

func main() {
	var value1 interface{} = nil // error
	_ = value1
	var value2 string
	if value2 == &quot;&quot; {
		value2 = &quot;test&quot;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;数组全部是值传递，没有引用传递&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你是一个C或则C++开发者，那么知道数组就是指针。当你向函数中传递数组时，函数会参照相同的内存区域，这样它们就可以修改原始的数据。但Go中的数组是数值，因此当你向函数中传递数组时，函数会得到原始数组数据的一份复制。如果你打算更新数组的数据，你将会失败。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;select下的所有case遍历是随机的，在使用的过程中要注意，这和switch是不同的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用接口实现一个类型分类函数：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func classifier(items ...interface{}) {
    for i, x := range items {
        switch x.(type) {
        case bool:
            fmt.Printf(&quot;param #%d is a bool\n&quot;, i)
        case float64:
            fmt.Printf(&quot;param #%d is a float64\n&quot;, i)
        case int, int64:
            fmt.Printf(&quot;param #%d is an int\n&quot;, i)
        case nil:
            fmt.Printf(&quot;param #%d is nil\n&quot;, i)
        case string:
            fmt.Printf(&quot;param #%d is a string\n&quot;, i)
        default:
            fmt.Printf(&quot;param #%d’s type is unknown\n&quot;, i)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Map值在获取的时候是无序的，所以当我们需要有序时就需要通过字符串数组排序间接得到&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;fmt&quot;
    &quot;sort&quot;
)

func main() {
    var m = map[string]int{
        &quot;unix&quot;:         0,
        &quot;python&quot;:       1,
        &quot;go&quot;:           2,
        &quot;javascript&quot;:   3,
        &quot;testing&quot;:      4,
        &quot;philosophy&quot;:   5,
        &quot;startups&quot;:     6,
        &quot;productivity&quot;: 7,
        &quot;hn&quot;:           8,
        &quot;reddit&quot;:       9,
        &quot;C++&quot;:          10,
    }
    var keys []string
    for k := range m {
        keys = append(keys, k)
    }
    sort.Strings(keys)
    for _, k := range keys {
        fmt.Println(&quot;Key:&quot;, k, &quot;Value:&quot;, m[k])
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;init函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开发过程我们经常会遇到主要逻辑开始前要声明或者一些全局的变量或者初始化操作，或者有时候我们仅仅需要import一些包，并不需要使用里面的函数，那就需要使用init初始化函数，一个package中可以有多个init，比如你在demo/A.go，demo/B.go都有一个init那么它们都会执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Go程序显示占用内存有时候并不是真正在用的内存，只是还没还给操作系统&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/blog/qyuhen&quot;&gt;雨痕学堂&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/&quot;&gt;Go的五十度灰：Golang新开发者要注意的陷阱和常见错误&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
    <link>https://dyxu.net/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/go-performance-optimization.html</link>
    <guid>https://dyxu.net/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/go-performance-optimization</guid>
    <pubDate>Mon, 17 Jul 2017 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>几种NoSQL的使用误区【转载】</title>
    <description>
&lt;p&gt;&lt;strong&gt;本文转载自&lt;a href=&quot;http://www.justinablog.com/archives/982&quot;&gt;博客&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最近经常看到关于NoSQL怎么用的讨论，加上自己也已经有四年多在正式项目中使用NoSQL数据库的经验，写下来与大家分享。&lt;/p&gt;

&lt;h2 id=&quot;1-通常不适合java程序&quot;&gt;1 通常不适合Java程序&lt;/h2&gt;

&lt;p&gt;NoSQL数据库最大的特点就是数据结构自由，不管是键值对还是JSON格式。使用动态语言，Ruby、Python或JavaScript，程序员可以非常流畅直接地书写JSON等数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;// JSON in Python
action = {
    &quot;_index&quot;: &quot;tickets-index&quot;,
    &quot;_id&quot;: j + 1,
    &quot;_source&quot;: {
        &quot;flight&quot;:df[1][j],
        &quot;price&quot;:float(df[2][j]),
        &quot;timestamp&quot;: datetime.now()}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在JavaScript中的JSON对象操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// JSON in JavaScript
var myJSONObject = {&quot;bindings&quot;: [
        {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;newURI&quot;, &quot;regex&quot;: &quot;^http://.*&quot;},
        {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;deleteURI&quot;, &quot;regex&quot;: &quot;^delete.*&quot;},
        {&quot;ircEvent&quot;: &quot;PRIVMSG&quot;, &quot;method&quot;: &quot;randomURI&quot;, &quot;regex&quot;: &quot;^random.*&quot;}
    ]
};

myJSONObject.bindings[0].method    // &quot;newURI&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但在Java中，需要非常复杂的字符串操作或第三方库来完成JSON转换，最简单的写法也是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// JSON in Java
JSONObject myJSONObject  = new JSONObject();
JSONArray bindings  = new JSONArray();
JSONObject event1  = new JSONObject();
JSONObject event2  = new JSONObject();
JSONObject event3 = new JSONObject();

event1.put(&quot;ircEvent&quot;, &quot;PRIVMSG&quot;);
event1.put(&quot;method&quot;, &quot;newURI&quot;);
// event2, event3
bindings.add(event1);
bindings.add(event2);
bindings.add(event3);
myJSONObject.put(&quot;bindings&quot;, bindings);
然后Java程序员会告诉你：

public static final String DO_NOT_HARD_CODE_THE_KEY = &quot;bindings&quot;;
myJSONObject.put(DO_NOT_HARD_CODE_THE_KEY, bindings);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2-没事别把sql数据库往nosql上迁&quot;&gt;2 没事别把SQL数据库往NoSQL上迁&lt;/h2&gt;

&lt;p&gt;既然SQL数据库都能正常工作，那为什么还要向NoSQL数据库迁移呢？这种做法就像要把所有线上Java程序全部用Python重写一样傻。&lt;/p&gt;

&lt;p&gt;但有几种场景，相信你曾经使用SQL数据库时会感到非常别扭，可以考虑把这部分数据库迁往NoSQL数据库：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果你使用SQL数据库来存储序列化对象，请改用NoSQL来存储：MongoDB这样的Document数据库是首选；&lt;/li&gt;
  &lt;li&gt;如果你使用SQL数据库来存储二进制流（图片、附件等），请改用NoSQL来存储：HDFS、S3甚至MongoDB的GridFS这样的File System很合适，不用再担心你的SQL数据库空间爆增后怎么分表的问题；&lt;/li&gt;
  &lt;li&gt;超过几十张表链接查询，只为取得一些字典数据及一些外键关联少数字段的数据：请毫不犹豫地使用Column based数据库如Cassandra、HBase，把你需要查询的结果数据直接设计在一个Column Family中，它们专门为解决多列查询问题存在，但你需要逆关系数据库设计范式：根据第一范式设计就对了；&lt;/li&gt;
  &lt;li&gt;一张不停扩展字段、包含许多Null值的表：月月改表改Mapping改Model不累么？换Document类的NoSQL数据库吧，省时省力又省心；&lt;/li&gt;
  &lt;li&gt;日志：这个场景就直接使用NoSQL数据库吧，起码不会和你的业务操作抢连接池资源，一不小心还会把你的业务表锁了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-列族数据库不适用作主数据存储&quot;&gt;3 列族数据库不适用作主数据存储&lt;/h2&gt;

&lt;p&gt;列族数据库面向特定的查询场景和特定的分析场景，比如你需要查询一个城市的所有用户和一个用户去过的所有城市，你是需要设计将用户作为Row Key设计一个数据存放结构，再将城市作为Row Key设计一个数据存放结构，分别支持两种快速查询的需求。对于数据分析，在有了具体的数据分析模型后，在列族数据库中建立Column Family再从数据源中导入数据，也是比较常见的做法。&lt;/p&gt;

&lt;p&gt;因为列族数据库是针对特定需求而作出的设计结构，所以别指望它作为你的主要存储数据库，然后再满足你所有的数据应用需求。我记得FaceBook使用Cassandra就只是为了解决Inbox的搜索请求。&lt;/p&gt;

&lt;h2 id=&quot;4-别把对象序列化到文件系统中&quot;&gt;4 别把对象序列化到文件系统中&lt;/h2&gt;

&lt;p&gt;本来以为不会有这样傻的事，但我偏偏就遇到了：在一个系统中，JSON对象被转换为流格式，再存储到Amazon S3中。这个问题的关键在于，理解你要存储的东西到底是Raw Data还是Structured Data.如果你已经有了一个JSON对象，那就原汁原味地往文档数据库里扔吧，别再节外生枝了。&lt;/p&gt;

&lt;h2 id=&quot;5-别问索引服务器该不该当成数据库&quot;&gt;5 别问索引服务器该不该当成数据库&lt;/h2&gt;

&lt;p&gt;数据库就有索引，索引文件也可以开启原数据存储。在关系型数据库中有一个问题就是：“既然索引可以让查询速度变快，为什么我们不在每一列都建立索引呢？”如果我们有了一个每一列都可以索引又不影响写入速度还可以自由格式的存储，它是不是数据库还重要吗？（言外之意是elasticsearch可以当做数据库来使用）&lt;/p&gt;
</description>
    <link>https://dyxu.net/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/nosql-misunderstanding.html</link>
    <guid>https://dyxu.net/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/nosql-misunderstanding</guid>
    <pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>Archlinux构建系统</title>
    <description>
&lt;h2 id=&quot;1-pacman命令&quot;&gt;1 pacman命令&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在archlinux中通过pacman来管理软件，全称为&lt;code&gt;package manager&lt;/code&gt;，使用方式如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;更新系统
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;pacman -Syu&lt;/code&gt; 更新整个系统&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Sy&lt;/code&gt; 同步本地包数据库和远程的仓库&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Su&lt;/code&gt; 根据本地包数据库更新系统&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Syu -ignore 包名&lt;/code&gt; 更新系统时不升级制定包&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;安装软件包
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;pacman -S包名&lt;/code&gt; 安装软件包，多个包间用空格分割&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Sy 包名&lt;/code&gt; 先同步本地数据库，再安装软件包&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Sf 包名&lt;/code&gt; 强制安装包&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Sv 包名&lt;/code&gt; 安装包，并打印详细信息&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -U 包名.pkg.tar.gz&lt;/code&gt; 安装本地软件包&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;删除软件包
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;pacman -R 包名&lt;/code&gt; 只删除制定包，不清理依赖包&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Rs 包名&lt;/code&gt; 删除包并删除依赖项&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Rd 包名&lt;/code&gt; 删除包时不检查其依赖&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Rn 包名&lt;/code&gt; 删除包及其配置文件&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Rsn 包名&lt;/code&gt; 删除包、依赖项及其配置文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;查询同步包数据库
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;pacman -Ss 关键字&lt;/code&gt; 在远程包数据库中查询含有关键字的包&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Si 包名&lt;/code&gt; 查询远程包数据库中该包的详细信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;查询本地包数据库
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;pacman -Q&lt;/code&gt; 列出系统中已安装包的包名&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Qs 关键字&lt;/code&gt;　在本地查询含有关键字的包&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Qi 包名&lt;/code&gt; 在本地包数据库中查询有关包的详细信息&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Ql 包名&lt;/code&gt; 查询并列出该包所含文件&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Qo /path/file&lt;/code&gt; 查询某文件属于何包&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Qdt&lt;/code&gt; 查询系统中的孤立包&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Qet&lt;/code&gt; 查询系统中的不被因依赖而安装的包&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他用法
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;pacman -Sw 包名&lt;/code&gt; 只下载包，不安装&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Sc&lt;/code&gt; 清理未安装的包文件（pacman 下载的包文件缓存于 /var/cache/pacman/pkg/ 目录）&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Scc&lt;/code&gt; 清理所有的缓存文件&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;pacman -Rs $(pacman -Qdtq)&lt;/code&gt; 递归删除系统中存在的孤立包&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-pacman原理&quot;&gt;2 pacman原理&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;pacman的原理是在远程仓库中下载压缩包到本地，再运行&lt;code&gt;pacman -U 包名.pkg.tar.xz&lt;/code&gt;安装。&lt;/p&gt;

&lt;p&gt;在运行 &lt;code&gt;pacman -S 包名&lt;/code&gt;时， pacman首先会从/var/lib/pacman/sync/文件夹里的几个数据库中搜索到nginx包对应的所有依赖包， 并递归搜索相应依赖包的所有依赖包，统计出安装 nginx必须要安装的所有包， 再从/var/lib/pacman/local/文件夹里查询这些包是否已经被安装，如果已被安装，则忽略安装此包及其依赖， 接着pacman就会从/etc/pacman.d/mirrorlist文件里选择一个包下载地址， 把这些包下载到/var/cache/pacman/pkg/文件夹里，安装包到系统里， 同时更新 /var/lib/pacman/local/文件夹，用来注册这些新安装的包， 到此安装过程结束。&lt;/p&gt;

&lt;h2 id=&quot;3-打包&quot;&gt;3 打包&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;首先我们看看软件包的结构，例如redis-3.2.9-1-x86_64.pkg.tar.xz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ tar xvJf redis-3.2.9-1-x86_64.pkg.tar.xz
$ tree redis
redis
├── etc
│   ├── logrotate.d
│   │   └── redis
│   └── redis.conf
└── usr
    ├── bin
    │   ├── redis-benchmark
    │   ├── redis-check-aof
    │   ├── redis-check-rdb
    │   ├── redis-cli
    │   ├── redis-sentinel -&amp;gt; redis-server
    │   └── redis-server
    ├── lib
    │   └── systemd
    │       └── system
    │           └── redis.service
    └── share
        └── licenses
            └── redis
                └── LICENSE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从目录树里我们可以看到，这就是安装后redis的所有文件， 其中有二进制文件和配置文件(usr/和etc/目录)， 并且路径与操作系统中的目录树相对应。
那么redis-3.2.9-1-x86_64.pkg.tar.xz包是如何产生的呢？其实，它是由archlinux的维护人员事先打包构建好后放到mirrorlist供pacman命令下载。而构建这个包，主要是依靠makepkg命令并配置PKGBUILD脚步自动完成下载、解压、编译并打包成archlinux包的。&lt;/p&gt;

&lt;h2 id=&quot;4-pkgbuild&quot;&gt;4 PKGBUILD&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;为了构建一个archlinux包， 我们只需编写PKGBUILD脚本， 然后运行makepkg命令， 其通过PKGBUILD脚本中参数和指令来自动化下载、解压、编译和打包全过程。&lt;/p&gt;

&lt;p&gt;PKGBUILD非常好写，通过shell语法定义一些makepkg命令需要的参数和指令。&lt;/p&gt;

&lt;p&gt;我们来看看上一小节中PKGBUILD中定义的参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pkgname：包名&lt;/li&gt;
  &lt;li&gt;pkgver：包版本&lt;/li&gt;
  &lt;li&gt;pkgrel：包的 release number&lt;/li&gt;
  &lt;li&gt;pkgdesc：包的简要概述&lt;/li&gt;
  &lt;li&gt;arch：包编译的体系结构&lt;/li&gt;
  &lt;li&gt;url：包官方网站 url&lt;/li&gt;
  &lt;li&gt;depends：包的依赖包&lt;/li&gt;
  &lt;li&gt;makedepends：编译这个包时需要的依赖包&lt;/li&gt;
  &lt;li&gt;source：包源码的下载地址&lt;/li&gt;
  &lt;li&gt;md5sums：上面 source 参数对应项的 md5sum，用来检测下载包的正确性&lt;/li&gt;
  &lt;li&gt;build：编译指令&lt;/li&gt;
  &lt;li&gt;package：打包指令&lt;/li&gt;
  &lt;li&gt;更多参数请参考&lt;a href=&quot;https://wiki.archlinux.org/index.php/PKGBUILD_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&quot;&gt;archlinux wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    <link>https://dyxu.net/%E6%8A%80%E6%9C%AF/archlinux-build-system.html</link>
    <guid>https://dyxu.net/%E6%8A%80%E6%9C%AF/archlinux-build-system</guid>
    <pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>一篇文让你秒懂CDN（转载）</title>
    <description>
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMzI3Njc1MA%3D%3D&amp;amp;mid=2650202731&amp;amp;idx=2&amp;amp;sn=a41438808c079dacb780f30657909b6d&amp;amp;chksm=833fe8cab44861dc12511d82322229de518d03ff66ea1491a7453d855b36feeeea7949c57a2a&amp;amp;scene=4&amp;amp;utm_source=tuicool&amp;amp;utm_medium=referral&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;著名的 &lt;strong&gt;《哲学简史》&lt;/strong&gt; 将2400年的西方哲学取精用宏、深入浅出地呈现给读者。虽然 &lt;strong&gt;内容分发网络（CDN）&lt;/strong&gt; 的历史要比哲学史短得多，但受此启发，&lt;strong&gt;Akamai&lt;/strong&gt;将CDN 18年来的演化历程浓缩到本文中，以期帮助人们了解CDN的成因、历年的变化以及未来发展前景。&lt;/p&gt;

&lt;h3 id=&quot;第一章-缓存年代1998年-2003年&quot;&gt;第一章 缓存年代（1998年-2003年&lt;/h3&gt;

&lt;p&gt;我们的旅程要从麻省理工学院一栋大楼的走廊开始，在这里，一位计算机科学家与一位数学教授见了面。这位计算机科学家就是  &lt;strong&gt;万维网的发明人Tim Berners Lee&lt;/strong&gt;  ，他当时注意到互联网正变得异常拥挤和缓慢。于是，他便向那位名叫Tom Leighton的数学教授请教，问其能否写个算法来解决该问题。在此后的日子里，Tom和他的研究生Danny Lewin不但写出了这个算法，还决定凭借此算法来建立一番事业。同年，  &lt;strong&gt;Akamai&lt;/strong&gt;   &lt;strong&gt;公司&lt;/strong&gt;  **  便正式成立，世界上第一个 CDN 也就此诞生。  **&lt;/p&gt;

&lt;p&gt;Leighton和Lewin最初的核心理念是 ** 将内容缓存在终端用户附近 ** ，使他们不必大费周折地访问这些内容。例如，以这种方式缓存内容，《星球大战》的影迷就能从附近的CDN服务器下载最新预告片，而不必从位于互联网另一端的原始服务器（Origin：原始服务器，存放内容或应用的数据中心）中获取。这种改变会带来三大好处：  用户能够更快地看到视频；网站运维人员可以将以前任务分派给CDN提供商，从而降低服务器负载；缓存能够减轻互联网中间一英里的流量负担 。&lt;/p&gt;

&lt;p&gt;Akamai就此一举成功。很快，每个人都开始将内容缓存到网络“边缘”。但互联网仍在增长，因此，人们急需 ** 新的利器对抗网络拥堵 ** 。&lt;/p&gt;

&lt;h3 id=&quot;第二章-加速年代2003年-2012年&quot;&gt;第二章 加速年代（2003年-2012年&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://img0.tuicool.com/Rf6bA3Z.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于静态内容，缓存能够很好地解决用户问题，但它对  ** 优化交易处理  ** 或 **  动态内容 **  却无能为力。因此，在面对涉及大量交易处理的各种在线应用，包括：  &lt;strong&gt;电子商务、游戏和企业应用时，缓存技术将面临重重挑战&lt;/strong&gt;  。试想：当您登录亚马逊网站并将某个商品放入购物车时，您无法缓存此类数据；当Netflix显示一张个性化广告时，您不能缓存这个信息；当一位客户经理在Salesforce软件上记录一个销售机会时，无法实现任何缓存。&lt;/p&gt;

&lt;p&gt;2003年，Akamai率先提出了世界上第一个应对该问题的解决办法，即“  &lt;strong&gt;动态网站加速&lt;/strong&gt;  ”。Akamai的工程师们将动态交易拆分开，并利用规模庞大且神奇的数学算法为交互中的每一元素找到最快的传送路径。现在，每当一项交易在终端用户与数据中心之间传输时，它将以最佳路径穿行互联网，自动避免拥堵和延迟。&lt;/p&gt;

&lt;p&gt;Akamai再次获得了空前成功。自此，人们能够在网上安心地购物和交流。而移动时代也随之到来。&lt;/p&gt;

&lt;h3 id=&quot;第三章-移动体验和安全时代2012年-2015年&quot;&gt;第三章 移动体验和安全时代（2012年-2015年&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://img1.tuicool.com/6ryaEjq.jpg!web&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2012年12月，全球最大的实体零售商沃尔玛宣称该公司购物网站的  &lt;strong&gt;40%&lt;/strong&gt;  访问量均来自移动设备。此后一个月，Akamai观察到  &lt;strong&gt;29%&lt;/strong&gt;  的移动用户都通过手机购买商品。不过，由于蜂窝网络性能不稳，用户均对手机体验不甚满意，并将之称为“ ** 最后一英里问题 ** ”。此外，呈爆炸式增长的移动设备、浏览器和网络连接（3G、4G、Wi-Fi）也使这一问题更加复杂。&lt;/p&gt;

&lt;p&gt;这一时期，Akamai再次担当起行业领导者的角色，引导人们走过了新的动荡移动年代。Akamai通过旗舰型  &lt;strong&gt;ION解决方案&lt;/strong&gt;  ，成功解决了“最后一英里问题”。该解决方案能够基于用户情况或使用情境（如：用户正在使用3G上网、iPhone和移动chrome浏览器访问您的网站，这就是用户情况/情境）动态优化内容和进行应用交付。&lt;/p&gt;

&lt;p&gt;同年，Akamai首先认识到它为内容交付而构建的云服务平台非常适于帮助企业增强在线业务安全。随后，Akamai正式发布了云安全解决方案，保护客户免受应用攻击和分布式拒绝服务攻击等网络威胁。&lt;/p&gt;

&lt;p&gt;Akamai将该方案称作  &lt;strong&gt;“保护和性能（Protect and Perform）”解决方案&lt;/strong&gt;  ，意谓着客户能一举两得，以最佳性能和最高安全性向其终端用户交付内容或应用。&lt;/p&gt;

&lt;p&gt;到2015年， ** CDN ** 已不再仅仅指缓存，还是加速、移动优化和安全的代表词。 不过，CDN的发展远未止步，更多激动人心的创新正在到来。&lt;/p&gt;

&lt;h3 id=&quot;第四章-业务逻辑支持年代截至目前&quot;&gt;第四章 业务逻辑支持年代（截至目前）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://img1.tuicool.com/eeqYjmi.jpg!web&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果您是一家公司电子商务部的数字化营销经理，并在最近重新设计了公司网站，现在希望比较一下新、旧网站的用户转化率。这就是一种典型的  &lt;strong&gt;A/B测试案例&lt;/strong&gt;  。&lt;/p&gt;

&lt;p&gt;以往人们通常依靠内部IT资源来完成这一目的，但这不仅成本高而且容易出错。现在，使用CDN即能实现。事实上，借助一个简单的、Akamai称之为  &lt;strong&gt;Cloudlet&lt;/strong&gt;  的服务，我们的  &lt;strong&gt;CDN&lt;/strong&gt;  便可与您的后端系统完美配合，将客户引向A/B站点并开展追踪，帮助您将用户转化数据与每次客户访问关联起来 。&lt;/p&gt;

&lt;p&gt;您可以将一些业务逻辑工作委托给CDN提供商，从而更快地将新服务推向市场，而您的IT人员也能够专注于核心职能。通过在互联网边缘执行业务逻辑，您还能实现更大的可扩展性和确保最佳用户体验。&lt;/p&gt;

&lt;p&gt;现在，对于所有已经建立网络系统的企业而言，CDN已成为一个得力的助手。CDN的黄金期已经到来。&lt;/p&gt;

&lt;div&gt;&lt;/div&gt;

&lt;h3 id=&quot;第五章-展望未来&quot;&gt;第五章 展望未来&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://img2.tuicool.com/6nmqEbA.jpg!web&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CDN简短的历史到这里就要结束了。但重要的是，我们应思考：“未来会有什么？”Akamai认为CDN可能或正在朝以下五个方向发展：&lt;/p&gt;

&lt;p&gt;1.无处不在的CDN&lt;/p&gt;

&lt;p&gt;广泛的部署是CDN发展良好的基础之一。CDN分布越广，距离终端用户就会越近，因而就越能带来更好的客户体验。Akamai预计未来的CDN平台将遍及手机信号塔、移动设备、人们的起居室、机顶盒、虚拟现实头盔等各个领域。&lt;/p&gt;

&lt;p&gt;2. 大数据分析
201
CDN携带了大量信息。比如，Akamai交付了全世界网络流量的15-30%。通过这些数据，Akamai可帮助企业深入了解客户体验和行为，并据此做出最明智的商业决策。此外，CDN还有可能涉及机器学习和人工智能等有趣的使用场景。&lt;/p&gt;

&lt;p&gt;3. 物联网（IoT）CDN&lt;/p&gt;

&lt;p&gt;物联网将建立在各种设备之间的API交互之上。Akamai能够为不同的API交易提供加速。CDN将在物联网流量和数据安全与管理方面增强物联网的解决方案能力。&lt;/p&gt;

&lt;p&gt;4. 行业化CDN&lt;/p&gt;

&lt;p&gt;每个行业都在技术、使用场景和法规方面对CDN服务提出了独特要求。随着CDN市场的蛋糕越来越大，Akamai预计将有一些CDN提供商专注于提供针对金融、证券和保险（FSI）、在线游戏、视频流媒体以及电子商务等具体行业的CDN解决方案。&lt;/p&gt;

&lt;p&gt;5. 虚拟专有化CDN&lt;/p&gt;

&lt;p&gt;虚拟专有化CDN是指专用于某一公司的虚拟CDN。利用更加优化的互联网传输和本地设备，电信公司可能向其全球或地方企业客户提供这种解决方案。&lt;/p&gt;

&lt;p&gt;CDN的未来发展将一片光明。在数字化转型进程中，各企业正变得日益依赖于互联网与其客户、合作伙伴和员工的沟通交流。而根植于互联网的CDN将成为企业推动数字化转型和商业成果的一个有力工具。&lt;/p&gt;

&lt;p&gt;如今，在线商务发展和不断提升的客户期望促进着CDN的演化。正如Nigel的书中所述，“  这是在整个哲学史中永恒的主题，每个时代都有它的特点和变革，但这个主题永远不会消失  ”。而CDN也是如此。&lt;/p&gt;
</description>
    <link>https://dyxu.net/%E8%A1%8C%E4%B8%9A/CDN.html</link>
    <guid>https://dyxu.net/%E8%A1%8C%E4%B8%9A/CDN</guid>
    <pubDate>Fri, 21 Oct 2016 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>Chrome漏字母解决方案</title>
    <description>
&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;Linux版本Chrome浏览器在打字速度快时会漏字母。例如：
我要打“今天天气真好” （jintiantianqizhenhao)
打得快时会变成：
“tq几年踢啊你真好”（jin(t)iantian(q)izhenhao)
两个字母直接到屏幕上了。&lt;/p&gt;

&lt;h2 id=&quot;解决方法&quot;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;应该是安装的fcitx版本有问题，安装fcitx-gtk2就可以了。&lt;/p&gt;
</description>
    <link>https://dyxu.net/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/chrome-fcitx.html</link>
    <guid>https://dyxu.net/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/chrome-fcitx</guid>
    <pubDate>Mon, 26 Sep 2016 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>程序员的30本书（转载）</title>
    <description>
&lt;h3 id=&quot;本文转载自推酷&quot;&gt;&lt;strong&gt;本文转载自&lt;a href=&quot;http://www.tuicool.com/articles/3iMzume&quot;&gt;推酷&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;“如果能时光倒流，回到过去，作为一个开发人员，你可以告诉自己在职业生涯初期应该读一本， 你会选择哪本书呢？我希望这个书单列表内容丰富，可以涵盖很多东西。”&lt;/p&gt;

&lt;h2 id=&quot;1代码大全-史蒂夫迈克康奈尔&quot;&gt;1、《代码大全》 史蒂夫·迈克康奈尔&lt;/h2&gt;

&lt;p&gt;推荐数：1684&lt;/p&gt;

&lt;p&gt;“优秀的编程实践的百科全书，《代码大全》注重个人技术，其中所有东西加起来， 就是我们本能所说的”编写整洁的代码”。这本书有50页在谈论代码布局。” —— Joel Spolsky&lt;/p&gt;

&lt;p&gt;对于新手来说，这本书中的观念有点高阶了。到你准备阅读此书时，你应该已经知道并实践过书中99%的观念。– esac&lt;/p&gt;

&lt;p&gt;Steve McConnell的原作《代码大全》(第1版)是公认的关于编程的最佳实践指南之一， 在过去的十多年间，本书一直在帮助开发人员编写更好的软件。&lt;/p&gt;

&lt;p&gt;现在，作者将这本经典著作全新演绎，融入了最前沿的实践技术，加入了上百个崭新的代码示例， 充分展示了软件构建的艺术性和科学性。 McConnell汇集了来自研究机构、学术界以及业界日常实践的主要知识， 把最高效的技术和最重要的原理交织融会为这本既清晰又实用的指南。&lt;/p&gt;

&lt;p&gt;无论您的经验水平如何，也不管您在怎样的开发环境中工作，也无论项目是大是小， 本书都将激发您的思维并帮助您构建高品质的代码。&lt;/p&gt;

&lt;p&gt;《代码大全（第2版）)》做了全面的更新，增加了很多与时俱进的内容，包括对新语言、新的开发过程与方法论的讨论等等。&lt;/p&gt;

&lt;h2 id=&quot;2程序员修炼之道&quot;&gt;2、《程序员修炼之道》&lt;/h2&gt;

&lt;p&gt;推荐数：1504&lt;/p&gt;

&lt;p&gt;对于那些已经学习过编程机制的程序员来说，这是一本卓越的书。 或许他们还是在校生，但对要自己做什么，还感觉不是很安全。&lt;/p&gt;

&lt;p&gt;就像草图和架构之间的差别。虽然你在学校课堂上学到的是画图，你也可以画的很漂亮， 但如果你觉得你不太知道从哪儿下手，如果某人要你独自画一个P2P的音乐交换网络图，那这本书就适合你了。—— Joel&lt;/p&gt;

&lt;p&gt;《程序员修炼之道:从小工到专家》内容简介：《程序员修炼之道》由一系列独立的部分组成， 涵盖的主题从个人责任、职业发展，知道用于使代码保持灵活、并且易于改编和复用的各种架构技术， 利用许多富有娱乐性的奇闻轶事、有思想性的例子及有趣的类比， 全面阐释了软件开发的许多不同方面的最佳实践和重大陷阱。&lt;/p&gt;

&lt;p&gt;无论你是初学者，是有经验的程序员，还是软件项目经理，《程序员修炼之道:从小工到专家》都适合你阅读。&lt;/p&gt;

&lt;h2 id=&quot;3计算机程序的构造和解释&quot;&gt;3、《计算机程序的构造和解释》&lt;/h2&gt;

&lt;p&gt;推荐数：916&lt;/p&gt;

&lt;p&gt;就个人而言，这本书目前为止对我影响醉倒的一本编程书。&lt;/p&gt;

&lt;p&gt;《代码大全》、《重构》和《设计模式》这些经典书会教给你高效的工作习惯和交易细节。 其他像《人件集》、《计算机编程心理学》和《人月神话》这些书会深入软件开发的心理层面。 其他书籍则处理算法。这些书都有自己所属的位置。&lt;/p&gt;

&lt;p&gt;然而《计算机程序的构造和解释》与这些不同。 这是一本会启发你的书，它会燃起你编写出色程序的热情； 它还将教会你认识并欣赏美； 它会让你有种敬畏，让你难以抑制地渴望学习更多的东西。&lt;/p&gt;

&lt;p&gt;其他书或许会让你成为一位更出色的程序员，但此书将一定会让你成为一名程序员。&lt;/p&gt;

&lt;p&gt;同时，你将会学到其他东西，函数式编程（第三章）、惰性计算、元编程、虚拟机、解释器和编译器。&lt;/p&gt;

&lt;p&gt;一些人认为此书不适合新手。 个人认为，虽然我并不完全认同要有一些编程经验才能读此书，但我还是一定推荐给初学者。 毕竟这本书是写给著名的6.001，是麻省理工学院的入门编程课程。 此书或许需要多做努力（尤其你在做练习的时候，你也应当如此），但这个价是对得起这本书的。&lt;/p&gt;

&lt;h2 id=&quot;4c程序设计语言&quot;&gt;4、《C程序设计语言》&lt;/h2&gt;

&lt;p&gt;推荐数：774&lt;/p&gt;

&lt;p&gt;这本书简洁易读，会教给你三件事：C 编程语言；如何像程序员一样思考；底层计算模型。 （这对理解”底层”非常重要）—— Nathan&lt;/p&gt;

&lt;p&gt;《C程序设计语言》(第2版新版)讲述深入浅出，配合典型例证，通俗易懂，实用性强， 适合作为大专院校计算机专业或非计算机专业的C语言教材，也可以作为从事计算机相关软硬件开发的技术人员的参考书。&lt;/p&gt;

&lt;p&gt;《C程序设计语言》(第2版新版)原著即为C语言的设计者之一Dennis M.Ritchie和著名的计算机科学家Brian W.Kernighan合著的 一本介绍C语言的权威经典著作。 我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。 原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。&lt;/p&gt;

&lt;p&gt;人们熟知的”hello,world”程序就是由本书首次引入的，现在，这一程序已经成为所有程序设计语言入门的第一课。&lt;/p&gt;

&lt;h2 id=&quot;5算法导论&quot;&gt;5、《算法导论》&lt;/h2&gt;

&lt;p&gt;推荐数：671&lt;/p&gt;

&lt;p&gt;《代码大全》教你如何正确编程； 《人月神话》教你如何正确管理； 《设计模式》教你如何正确设计……&lt;/p&gt;

&lt;p&gt;在我看来，代码只是一个工具，并非精髓。 开发软件的主要部分是创建新算法或重新实现现有算法。 其他部分则像重新组装乐高砖块或创建”管理”层。&lt;/p&gt;

&lt;p&gt;我依然梦想这样的工作，我的大部分时间（&amp;gt;50%）是在写算法，其他”管理”细节则留给其他人…… —— Ran Biron&lt;/p&gt;

&lt;p&gt;• 经典的算法书,被亚马逊网，《程序员》等评选为2006年最受读者喜爱的十大IT图书之一。&lt;/p&gt;

&lt;p&gt;• 算法领域的标准教材，全球多所知名大学选用&lt;/p&gt;

&lt;p&gt;• MIT名师联手铸就，被誉为”计算机算法的圣经”&lt;/p&gt;

&lt;p&gt;• 编写上采用了”五个一”，即一章介绍一个算法、一种设计技术、一个应用领域和一个相关话题。&lt;/p&gt;

&lt;h2 id=&quot;6重构改善既有代码的设计&quot;&gt;6、《重构：改善既有代码的设计》&lt;/h2&gt;

&lt;p&gt;推荐数：617&lt;/p&gt;

&lt;p&gt;《重构:改善既有代码的设计》清晰地揭示了重构的过程，解释了重构的原理和最佳实践方式， 并给出了何时以及何地应该开始挖掘代码以求改善。 书中给出了70多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。&lt;/p&gt;

&lt;p&gt;《重构:改善既有代码的设计》提出的重构准则将帮助你一次一小步地修改你的代码，从而减少了开发过程中的风险。&lt;/p&gt;

&lt;p&gt;《重构:改善既有代码的设计》适合软件开发人员、项目管理人员等阅读， 也可作为高等院校计算机及相关专业师生的参考读物。&lt;/p&gt;

&lt;p&gt;我想我不得不推荐《重构》：改进现有代码的设计。—— Martin&lt;/p&gt;

&lt;p&gt;我必须承认，我最喜欢的编程语录是出自这本书：任何一个傻瓜都能写出计算机能理解的程序， 而优秀的程序员却能写出别人能读得懂的程序。—— Martin Fowler&lt;/p&gt;

&lt;h2 id=&quot;7设计模式&quot;&gt;7、《设计模式》&lt;/h2&gt;

&lt;p&gt;推荐数：617&lt;/p&gt;

&lt;p&gt;自1995年出版以来，本书一直名列Amazon和各大书店销售榜前列。 近10年后，本书仍是Addison-Wesley公司2003年最畅销的图书之一。 中文版销售逾4万册。&lt;/p&gt;

&lt;p&gt;就我而言，我认为四人帮编著的《设计模式》是一本极为有用的书。 虽然此书并不像其他建议一样有关”元”编程，但它强调封装诸如模式一类的优秀编程技术， 因而鼓励其他人提出新模式和反模式（antipatterns），并运用于编程对话中。—— Chris Jester-Young&lt;/p&gt;

&lt;h2 id=&quot;8人月神话&quot;&gt;8、《人月神话》&lt;/h2&gt;

&lt;p&gt;推荐数：588&lt;/p&gt;

&lt;p&gt;在软件领域，很少能有像《人月神话》一样具有深远影响力并且畅销不衰的著作。&lt;/p&gt;

&lt;p&gt;Brooks博士为人们管理复杂项目提供了最具洞察力的见解。 既有很多发人深省的观点，又有大量软件工程的实践。 本书内容来自Brooks博士在IBM公司System/360家族和OS/360中的项目管理经验。&lt;/p&gt;

&lt;p&gt;该书英文原版一经面世，即引起业内人士的强烈反响，后又译为德、法、日、俄中等多种语言，全球销量数百万册。 确立了其在行业内的经典地位。&lt;/p&gt;

&lt;h2 id=&quot;9计算机程序设计艺术&quot;&gt;9、《计算机程序设计艺术》&lt;/h2&gt;

&lt;p&gt;推荐数：542&lt;/p&gt;

&lt;p&gt;《计算机程序设计艺术》系列著作对计算机领域产生了深远的影响。 这一系列堪称一项浩大的工程，自1962年开始编写，计划出版7卷，目前已经出版了4卷。&lt;/p&gt;

&lt;p&gt;《美国科学家》杂志曾将这套书与爱因斯坦的《相对论》等书并列称为20世纪最重要的12本物理学著作。 目前Knuth正将毕生精力投入到这部史诗性著作的撰写中。&lt;/p&gt;

&lt;p&gt;这是高德纳倾注心血写的一本书。—— Peter Coulton&lt;/p&gt;

&lt;h2 id=&quot;10编译原理龙书&quot;&gt;10、《编译原理》（龙书）&lt;/h2&gt;

&lt;p&gt;推荐数：462&lt;/p&gt;

&lt;p&gt;我很奇怪，居然没人提到龙书。（或许已有推荐，我没有看到）。 我从没忘过此书的第一版封面。 此书让我知道了编译器是多么地神奇绝妙。- DB&lt;/p&gt;

&lt;h2 id=&quot;11深入浅出设计模式&quot;&gt;11、《深入浅出设计模式》&lt;/h2&gt;

&lt;p&gt;推荐数：445&lt;/p&gt;

&lt;p&gt;强大的写作阵容。&lt;/p&gt;

&lt;p&gt;•《Head First设计模式》(中文版) 作者Eric Freeman；&lt;/p&gt;

&lt;p&gt;•  ElElisabeth Freeman是作家、讲师和技术顾问。&lt;/p&gt;

&lt;p&gt;• Eric拥有耶鲁大学的计算机科学博士学位，E1isabath拥有耶鲁大学的计算机科学硕士学位。&lt;/p&gt;

&lt;p&gt;• Kathy Sierra(javaranch．com的创始人)FHBert Bates是畅销的HeadFirst系列书籍的创立者，也是Sun公司Java开发员认证考试的开发者。&lt;/p&gt;

&lt;p&gt;本书的产品设计应用神经生物学、认知科学，以及学习理论，这使得这本书能够将这些知识深深地印在你的脑海里， 不容易被遗忘。&lt;/p&gt;

&lt;p&gt;本书的编写方式采用引导式教学，不直接告诉你该怎么做，而是利用故事当作引子，带领读者思考并想办法解决问题。 解决问题的过程中又会产生一些新的问题，再继续思考、继续解决问题，这样可以加深体会。&lt;/p&gt;

&lt;p&gt;作者以大量的生活化故事当背景，例如第1章是鸭子，第2章是气象站，第3章是咖啡店， 书中搭配大量的插图(几乎每一页都有图)，所以阅读起来生动有趣，不会感觉到昏昏欲睡。&lt;/p&gt;

&lt;p&gt;作者还利用歪歪斜斜的手写字体，增加”现场感”。 精心设计许多爆笑的对白，让学习过程不会太枯燥。 还有模式告白节目，将设计模式拟人化成节目来宾，畅谈其内在的一切。 每一章都有数目不等的测验题。 每章最后有一页要点整理，这也是精华所在，我都是利用这一页做复习。&lt;/p&gt;

&lt;p&gt;我知道四人帮的《设计模式》是一本标准书，但倒不如先看看这部大部头，此书更为简易。 一旦你了解了解了基本原则，可以去看四人帮的那本圣经了。- Calanus&lt;/p&gt;

&lt;h2 id=&quot;12哥德尔艾舍尔巴赫书集异璧之大成&quot;&gt;12、《哥德尔、艾舍尔、巴赫书：集异璧之大成》&lt;/h2&gt;

&lt;p&gt;推荐数：437&lt;/p&gt;

&lt;p&gt;如果下昂真正深入阅读，我推荐道格拉斯·侯世达（Douglas Hofstadter）的《哥德尔、艾舍尔、巴赫书》。 他极为深入研究了程序员每日都要面对的问题：递归、验证、证明和布尔代数。 这是一本很出色的读物，难度不大，偶尔有挑战，一旦你要鏖战到底，将是非常值得的。 – Jonik&lt;/p&gt;

&lt;h2 id=&quot;13代码整洁之道&quot;&gt;13、《代码整洁之道》&lt;/h2&gt;

&lt;p&gt;推荐数：329&lt;/p&gt;

&lt;p&gt;细节之中自有天地，整洁成就卓越代码&lt;/p&gt;

&lt;p&gt;尽管糟糕的代码也能运行，但如果代码不整洁，会使整个开发团队泥足深陷， 写得不好的代码每年都要耗费难以计数的时间和资源。 然而这种情况并非无法避免。&lt;/p&gt;

&lt;p&gt;著名软件专家RoberfC.Marlin在《代码整洁之道》中为你呈现出了革命性的视野。 Martin携同ObjectMetltor公司的同事，从他们有关整洁代码的最佳敏捷实践中提炼出软件技艺的价值观， 以飨读者，让你成为更优秀的程序员——只要你着手研读《代码整洁之道》。&lt;/p&gt;

&lt;p&gt;阅读《代码整洁之道》需要你做些什么呢？你将阅读代码——大量代码。 《代码整洁之道》促使你思考代码中何谓正确，何谓错误。 更重要的是，《代码整洁之道》将促使你重新评估自己的专业价值观，以及对自己技艺的承诺。&lt;/p&gt;

&lt;p&gt;从《代码整洁之道》中可以学到：&lt;/p&gt;

&lt;p&gt;• 好代码和糟糕的代码之间的区别；&lt;/p&gt;

&lt;p&gt;• 如何编写好代码，如何将糟糕的代码转化为好代码；&lt;/p&gt;

&lt;p&gt;• 如何创建好名称、好函数、好对象和好类；&lt;/p&gt;

&lt;p&gt;• 如何格式化代码以实现其可读性的最大化；&lt;/p&gt;

&lt;p&gt;• 如何在不妨碍代码逻辑的前提下充分实现错误处理；&lt;/p&gt;

&lt;p&gt;• 如何进行单元测试和测试驱动开发。&lt;/p&gt;

&lt;p&gt;虽然《代码整洁之道》和《代码大全》有很多共同之处，但它有更为简洁更为实际的清晰例子。 – Craig P. Motlin&lt;/p&gt;

&lt;h2 id=&quot;14effectivec和more-effective-c&quot;&gt;14、《EffectiveC++》和《More Effective C++》&lt;/h2&gt;

&lt;p&gt;推荐数：297&lt;/p&gt;

&lt;p&gt;在我职业生涯早期，Scott Meyer的《Effective C++》和后续的《More Effective C++》都对我的编程能力有着直接影响。 正如当时的一位朋友所说，这些书缩短你培养编程技能的过程，而其他人可能要花费数年。&lt;/p&gt;

&lt;p&gt;去年对我影响最大的一本书是《大教堂与市集》，该书教会我很有关开源开发过程如何运作，和如何处理我代码中的Bug。 – John Channing&lt;/p&gt;

&lt;h2 id=&quot;15编程珠玑&quot;&gt;15、《编程珠玑》&lt;/h2&gt;

&lt;p&gt;推荐数：282&lt;/p&gt;

&lt;p&gt;多年以来，当程序员们推选出最心爱的计算机图书时，《编程珠玑》总是位列前列。 正如自然界里珍珠出自细沙对牡蛎的磨砺，计算机科学大师Jon Bentley以其独有的洞察力和创造力， 从磨砺程序员的实际问题中凝结出一篇篇不朽的编程”珠玑”， 成为世界计算机界名刊《ACM通讯》历史上最受欢迎的专栏， 最终结集为两部不朽的计算机科学经典名著，影响和激励着一代又一代程序员和计算机科学工作者。&lt;/p&gt;

&lt;p&gt;本书为第一卷，主要讨论计算机科学中最本质的问题：如何正确选择和高效地实现算法。&lt;/p&gt;

&lt;p&gt;尽管我不得不羞愧地承认，书中一半的东西我都没有理解，但我真的推荐《编程珠玑》，书中有些令人惊奇的东西。 – Matt Warren&lt;/p&gt;

&lt;h2 id=&quot;16修改代码的艺术by-michael-feathers&quot;&gt;16、《修改代码的艺术》by Michael Feathers&lt;/h2&gt;

&lt;p&gt;本书是继《重构》和《重构与模式》之后探讨修改代码技术的又一里程碑式的著作， 而且从涵盖面和深度上都超过了前两部经典。 书中不仅讲述面向对象语言（Java、C#和C++）代码，也有专章讨论C这样的过程式语言。&lt;/p&gt;

&lt;p&gt;作者将理解、测试和修改代码的原理、技术和最新工具（自动化重构工具、单元测试框架、仿对象、集成测试框架等）， 与解依赖技术和大量开发和设计优秀代码的原则、最佳实践相结合，许多内容非常深入，而且常常发前人所未发。&lt;/p&gt;

&lt;p&gt;书中处处体现出作者独到的洞察力，以及多年开发和指导软件项目所积累的丰富经验和深厚功力。 通过这部集大成之作，你不仅能掌握最顶尖的修改代码技术，还可以大大提高对代码和软件开发的领悟力。&lt;/p&gt;

&lt;p&gt;我认为没有任何一本书能向这本书一样影响了我的编程观点。 它明确地告诉你如何处理其他人的代码，含蓄地教会你避免哪些（以及为什么要避免）。- Wolfbyte&lt;/p&gt;

&lt;p&gt;同意。很多开发人员讨论用干净的石板来编写软件。 但我想几乎所有开发人员的某些时候是在吃其他开发人员的狗食。– Bernard Dy&lt;/p&gt;

&lt;h2 id=&quot;17编码隐匿在计算机软硬件背后的语言&quot;&gt;17、《编码：隐匿在计算机软硬件背后的语言》&lt;/h2&gt;

&lt;p&gt;这是一本讲述计算机工作原理的书。&lt;/p&gt;

&lt;p&gt;不过，你千万不要因为”工作原理”之类的字眼就武断地认为，它是晦涩而难懂的。 作者用丰富的想象和清晰的笔墨将看似繁杂的理论阐述得通俗易懂，你丝毫不会感到枯燥和生硬。 更重要的是，你会因此而获得对计算机工作原理较深刻的理解。 这种理解不是抽象层面上的，而是具有一定深度的，这种深度甚至不逊于”电气工程师”和”程序员”的理解。&lt;/p&gt;

&lt;p&gt;不管你是计算机高手，还是对这个神奇的机器充满敬畏之心的菜鸟， 都不妨翻阅一下《编码:隐匿在计算机软硬件背后的语言》，读一读大师的经典作品，必然会有收获。&lt;/p&gt;

&lt;p&gt;我推荐Charles Petzold的《编码》。 在这个充满工具和IDE的年代，很多复杂度已经从程序员那”抽取”走了，这本书一本开眼之作。 – hemil&lt;/p&gt;

&lt;h2 id=&quot;18禅与摩托车维修艺术--zen-and-the-art-of-motorcycle-maintenance&quot;&gt;18、《禅与摩托车维修艺术 / Zen and the Art of Motorcycle Maintenance》&lt;/h2&gt;

&lt;p&gt;对我影响最大的那本书是 Robert Pirsig 的《禅与摩托车维修艺术》。 不管你做什么事，总是要力求完美，彻底了解你手中的工具和任务，更为重要的是， 要有乐趣（因为如果你做事有乐趣，一切将自发引向更好的结果）。 – akr&lt;/p&gt;

&lt;h2 id=&quot;19peopleware--人件集人性化的软件开发&quot;&gt;19、《Peopleware / 人件集:人性化的软件开发》&lt;/h2&gt;

&lt;p&gt;Demarco 和 Lister 表明，软件开发中的首要问题是人，并非技术。 他们的答案并不简单，只是令人难以置信的成功。 第二版新增加了八章内容。 – Eduardo Molteni&lt;/p&gt;

&lt;h2 id=&quot;20coders-at-work--编程人生&quot;&gt;20、《Coders at Work / 编程人生》&lt;/h2&gt;

&lt;p&gt;这是一本访谈笔录，记录了当今最具个人魅力的15位软件先驱的编程生涯。 包括DonaldKnuth、Jamie Zawinski、Joshua Bloch、Ken Thompson等在内的业界传奇人物，为我们讲述了 他们是怎么学习编程的，在编程过程中发现了什么以及他们对未来的看法， 并对诸如应该如何设计软件等长久以来一直困扰很多程序员的问题谈了自己的观点。&lt;/p&gt;

&lt;p&gt;一本非常有影响力的书，可以从中学到一些业界顶级人士的经验，了解他们如何思考并工作。 – Jahanzeb Farooq&lt;/p&gt;

&lt;h2 id=&quot;21surely-youre-joking-mr-feynman--别闹了费曼先生&quot;&gt;21、《Surely You’re Joking, Mr. Feynman! / 别闹了，费曼先生！》&lt;/h2&gt;

&lt;p&gt;虽然这本书可能有点偏题，但不管你信不信，这本书曾在计算机科学专业课程的阅读列表之上。 一个优秀的角色模型，一本有关好奇心的优秀书籍。 – mike511&lt;/p&gt;

&lt;h2 id=&quot;22effective-java-中文版&quot;&gt;22、《Effective Java 中文版》&lt;/h2&gt;

&lt;p&gt;此书第二版教你如何编写漂亮并高效的代码，虽然这是一本Java书，但其中有很多跨语言的理念。 – Marcio Aguiar&lt;/p&gt;

&lt;h2 id=&quot;23patterns-of-enterprise-application-architecture--企业应用架构模式&quot;&gt;23、《Patterns of Enterprise Application Architecture / 企业应用架构模式》&lt;/h2&gt;

&lt;p&gt;很奇怪，还没人推荐 Martin Fowler 的《企业应用架构模式》- levi rosol&lt;/p&gt;

&lt;h2 id=&quot;24the-little-schemer和the-seasoned-schemer-nmiranda&quot;&gt;24、《The Little Schemer》和《The Seasoned Schemer》 nmiranda&lt;/h2&gt;

&lt;p&gt;这两本是LISP的英文书，尚无中文版。 美国东北大学网站上有电子版。&lt;/p&gt;

&lt;h2 id=&quot;25交互设计之路-英文名the-inmates-are-running-the-asylum-why-high-tech-products-drive-us-crazyand-how-to-restore-the-sanity该书作者alan-cooper人称visual-basic之父交互设计之父&quot;&gt;25、《交互设计之路》 英文名：《The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity》该书作者：Alan Cooper，人称Visual Basic之父，交互设计之父。&lt;/h2&gt;

&lt;p&gt;本书是基于众多商务案例，讲述如何创建更好的、高客户忠诚度的软件产品和基于软件的高科技产品的书。 本书列举了很多真实可信的实际例子，说明目前在软件产品和基于软件的高科技产品中，普遍存在着”难用”的问题。&lt;/p&gt;

&lt;p&gt;作者认为，”难用”问题是由这些产品中存在着的高度”认知摩擦”引起的， 而产生这个问题的根源在于现今软件开发过程中欠缺了一个为用户利益着想的前期”交互设计”阶段。 “难用”的产品不仅损害了用户的利益，最终也将导致企业的失败。&lt;/p&gt;

&lt;p&gt;本书通过一些生动的实例，让人信服地讲述了由作者倡导的”目标导向”交互设计方法在解决”难用”问题方面的有效性， 证实了只有改变现有观念，才能有效地在开发过程中引入交互设计，将产品的设计引向成功。&lt;/p&gt;

&lt;p&gt;本书虽然是一本面向商务人员而编写的书，但也适合于所有参与软件产品和基于软件的高科技产品开发的专业人士， 以及关心软件行业和高科技行业现状与发展的人士阅读。&lt;/p&gt;

&lt;p&gt;他还有另一本中文版著作：《About Face 3 交互设计精髓》&lt;/p&gt;

&lt;h2 id=&quot;26whys-poignant-guide-to-ruby-&quot;&gt;26、《Why’s (Poignant) Guide to Ruby 》&lt;/h2&gt;

&lt;p&gt;如果你不是程序员，阅读此书可能会很有趣，但如果你已经是个程序员，可能会有点乏味。&lt;/p&gt;

&lt;h2 id=&quot;27unix编程艺术&quot;&gt;27、《Unix编程艺术》&lt;/h2&gt;

&lt;p&gt;It is useful regardless operating system you use. – J.F. Sebastian&lt;/p&gt;

&lt;p&gt;不管你使用什么操作系统，这本书都很有用。 – J.F. Sebastian&lt;/p&gt;

&lt;h2 id=&quot;28高效程序员的45个习惯敏捷开发修炼之道&quot;&gt;28、《高效程序员的45个习惯：敏捷开发修炼之道》&lt;/h2&gt;

&lt;p&gt;45个习惯，分为7个方面：工作态度、学习、软件交付、反馈、编码、调试和协作。&lt;/p&gt;

&lt;p&gt;每一个具体的习惯里，一开始提出一个谬论，然后展开分析，之后有正队性地提出正确的做法，并设身处地地讲出了正确做法给你个人的”切身感受”，最后列出几条注意事项，帮助你修正自己的做法（”平衡的艺术”）。&lt;/p&gt;

&lt;h2 id=&quot;29测试驱动开发&quot;&gt;29、《测试驱动开发》&lt;/h2&gt;

&lt;p&gt;前面已经提到的很多书都启发了我，并影响了我，但这本书每位程序员都应该读。 它向我展示了单元测试和TDD的重要性，并让我很快上手。 – Curro&lt;/p&gt;

&lt;p&gt;我不关心你的代码有多好或优雅。 如果你没有测试，你或许就如同没有编写代码。 这本书得到的推荐数应该更高些。 人们讨论编写用户喜欢的软件，或既设计出色并健壮的高效代码，但如果你的软件有一堆bug，谈论那些东西毫无意义。– Adam Gent&lt;/p&gt;

&lt;h2 id=&quot;30点石成金访客至上的网页设计秘笈&quot;&gt;30、《点石成金:访客至上的网页设计秘笈》&lt;/h2&gt;

&lt;p&gt;可用性设计是Web设计中最重要也是难度最大的一项任务。 《点石成金－访客至上的网页设计秘笈（原书第二版）》作者根据多年从业的经验，剖析用户的心理， 在用户使用的模式、为扫描进行设计、导航设计、主页布局、可用性测试等方面提出了许多独特的观点， 并给出了大量简单、易行的可用性设计的建议。&lt;/p&gt;

&lt;p&gt;本书短小精炼，语言轻松诙谐，书中穿插大量色彩丰富的屏幕截图、趣味丛生的卡通插图以及包含大量信息的图表， 使枯燥的设计原理变得平易近人。&lt;/p&gt;

&lt;p&gt;本书适合从事Web设计和Web开发的技术人员阅读，特别适合为如何留住访问者而苦恼的网站/网页设计人员阅读。 这是一本关于Web设计原则而不是Web设计技术的书。&lt;/p&gt;

&lt;p&gt;本书作者是Web设计专家，具有丰富的实践经验。 他用幽默的语言为你揭示Web设计中重要但却容易被忽视的问题，只需几个小时， 你便能对照书中讲授的设计原则找到网站设计的症结所在，令你的网站焕然一新。&lt;/p&gt;

&lt;p&gt;取决于你所追求的目标。 我喜欢《代码大全》是因纯编程，《点石成金》是一本有关UI设计的卓越书籍。 – Justin Standard&lt;/p&gt;
</description>
    <link>https://dyxu.net/%E6%8A%80%E6%9C%AF/books-for-programers.html</link>
    <guid>https://dyxu.net/%E6%8A%80%E6%9C%AF/books-for-programers</guid>
    <pubDate>Tue, 05 Jul 2016 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>Keith Schwarz算法实现</title>
    <description>
&lt;p&gt;Keith Schwarz是一个斯坦福大学计算机科学系的讲师，他在自己的
&lt;a href=&quot;http://www.keithschwarz.com/interesting/&quot;&gt;主页&lt;/a&gt;上实现了各种各样有意思的算法和数据结果。&lt;/p&gt;

&lt;h2 id=&quot;算法列表&quot;&gt;算法列表&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;算法&lt;/td&gt;
      &lt;td&gt;链接&lt;/td&gt;
      &lt;td&gt;语言&lt;/td&gt;
      &lt;td&gt;简介&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Binomial Heap&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=binomial-heap&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a binomial heap data structure for use as a priority queue.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bounded Priority Queue&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=bounded-pqueue&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a priority queue with a fixed upper limit to its size..&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Matrix&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=matrix&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A collection of classes for manipulating matrices.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VList&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=vlist&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of the List abstraction backed by a VList.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Function Wrapper&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=function&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A C++ wrapper class around unary functions.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=string&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a string abstraction that uses the small string optimization.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;nstream&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=nstream&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An stream class that sends and receives data over a network.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Snake&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=snake&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the game Snake with a rudimentary AI.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mergesort&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=mergesort&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the mergesort algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Next Permutation&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=next-permutation&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the next_permutation STL algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Interval Heap&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=interval-heap&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of a double-ended priority queue using an interval heap.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Linear-Time Selection&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=median-of-medians&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A deterministic, linear-time selection algorithm using the median-of-medians algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Heapsort&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=heapsort&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the heapsort algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Union-Find&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=union-find&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of a disjoint-set data structure using a disjoint set forest.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Radix Sort&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=radix-sort&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the radix sort algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Rational&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=rational&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A data structure representing a rational number.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DPLL&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=dpll&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Haskell&lt;/td&gt;
      &lt;td&gt;An implementation of the DPLL algorithm for solving CNF-SAT.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Smoothsort&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=smoothsort&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the smoothsort algorithm, an adaptive heapsort variant.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Extendible Array&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=extendible-array&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;A dynamic array class with O(1) worst-case runtime lookup and append.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;In-Place Merge&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=inplace-merge&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a merge algorithm that runs in-place.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Random Shuffle&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=random-shuffle&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An algorithm for generating a random permutation of a set of elements.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Random Sample&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=random-sample&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An O(n) time, O(1) space algorithm for randomly choosing k elements out of a stream with uniform probability.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Natural Mergesort&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=natural-mergesort&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of natural mergesort, an adaptive variant of mergesort.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Interpolation Search&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=interpolation-search&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the interpolation search algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Introsort&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=introsort&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the introsort algorithm, a fast hybrid of quicksort, heapsort, and insertion sort.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Hashed Array Tree&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=hashed-array-tree&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of a dynamic array backed by a hashed array tree.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Recurrence Solver&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=recurrence&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A fast algorithm for generating terms of a sequence defined by a linear recurrence relation.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fibonacci Heap&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=fibonacci-heap&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of a priority queue backed by a Fibonacci heap.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dijkstra’s Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=dijkstra&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of Dijkstra’s algorithm for single-source shortest paths.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Prim’s Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=prim&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of Prim’s algorithm for computing minimum spanning trees.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Kruskal’s Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=kruskal&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of Kruskal’s algorithm for computing minimum spanning trees.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Majority Element&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=majority-element&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A fast, linear-time algorithm for finding the majority element of a data set.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Haar Transform&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=haar&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A set of functions to decompose a sequence of values into a sum of Haar wavelets.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Argmax&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=argmax&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A pair of functions to compute the arg min or max of a function on some range.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Derivative&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=derivative&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A function object that approximates the derivative of a function.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Levenshtein Distance&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=levenshtein&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An algorithm for computing the Levenshtein distance between two sequences.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Skiplist&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=skiplist&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a skip list, a randomized data structure for maintaining a sorted collection.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;van Emde Boas Tree&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=van-emde-boas-tree&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a sorted associative array backed by a van Emde Boas tree.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cuckoo HashMap&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=cuckoo-hashmap&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of a hash table using cuckoo hashing.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Needleman-Wunsch Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=needleman-wunsch&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the Needleman-Wunsch algorithm for optimal string alignment.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Treap&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=treap&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a sorted associative array backed by a treap.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Floyd-Warshall Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=floyd-warshall&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of the Floyd-Warshall algorithm for all-pairs shortest paths in a graph.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Power Iteration&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=power-iteration&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the power iteration algorithm for finding dominant eigenvectors.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Edmonds’s Matching Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=edmonds-matching&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of Edmonds’s matching algorithm for finding maximum matchings in undirected graphs.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Kosaraju’s Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=kosaraju&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of Kosaraju’s algorithm algorithm for finding strongly connected components of a directed graph.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2-SAT&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=2sat&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;A linear-time algorithm for solving 2-SAT.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bellman-Ford Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=bellman-ford&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of the Bellman-Ford algorithm for single-source shortest paths.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Topological Sort&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=topological-sort&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An algorithm for computing a topological sort of a directed acyclic graph.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Graham Scan&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=graham-scan&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the Graham scan for finding convex hulls in 2D space.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bipartite Testing&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=bipartite-verify&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;A linear-time algorithm for checking whether a directed graph is bipartite.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Johnson’s Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=johnson&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of Johnson’s algorithm for all-pairs shortest paths.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Strassen Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=strassen&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the Strassen algorithm for fast matrix multiplication.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cartesian Tree Sort&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=cartesian-tree-sort&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of Cartesian tree sort, an adaptive, out-of-place heapsort variant.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ford-Fulkerson Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=ford-fulkerson&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of the Ford-Fulkerson maximum-flow algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Scaling Ford-Fulkerson&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=ford-fulkerson-scaling&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An modification of the Ford-Fulkerson maximum-flow algorithm that uses scaling to achieve polynomial time..&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Splay Tree&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=splay-tree&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a sorted associative array backed by a splay tree.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ternary Search Tree&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=ternary-search-tree&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a sorted set of strings backed by a ternary search tree.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ring Buffer&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=ring-buffer&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of a FIFO queue using a ring buffer.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AVL Tree&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=avl-tree&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A sorted associative container backed by an AVL tree.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Rabin-Karp Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=rabin-karp&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the Rabin-Karp algorithm for string matching.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RPN Evaluator&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=rpn-evaluate&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++ / strain&lt;/td&gt;
      &lt;td&gt;A library to tokenize and evaluate simple arithmetic expressions in reverse Polish notation.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shunting-Yard Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=shunting-yard&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++ / strain&lt;/td&gt;
      &lt;td&gt;An implementation of Dijkstra’s shunting-yard algorithm for converting infix expressions to reverse-Polish notation.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Skew Binomial Heap&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=skew-binomial-heap&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a priority queue backed by a skew binomial heap.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2/3 Heap&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=two-three-heap&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a priority queue whose branching factor alternates at different levels to maximize performance.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Zeckendorf Logarithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=zeckendorf-logarithm&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An algorithm based on Zeckendorf representations that efficiently computes logarithms.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Factoradic Permutations&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=factoradic-permutation&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A set of algorithms for generating permutations using the factoradic number system.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Binary Cyclic Subsets&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=binary-subset&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A set of algorithms for generating subsets in lexicographical order using binary numbers and cyclic shifts.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fibonacci Iterator&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=fibonacci-iterator&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An STL-style iterator for iterating over the Fibonacci numbers.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fibonacci Search&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=fibonacci-search&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the Fibonacci search algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Euclid’s Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=euclid&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Haskell&lt;/td&gt;
      &lt;td&gt;An implementation of Euclid’s algorithm and applications to continued fractions and the extended Euclidean algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Find Duplicate&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=find-duplicate&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;An algorithm to find a repeated element in an array using Floyd’s cycle-finding algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Permutation Generator&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=permutation-generator&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;A generator for producing all permutations of a list of elements.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Matrix Find&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=matrix-find&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;A solution to the classic interview question of searching a sorted matrix for a particular value.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Binary GCD&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=binary-gcd&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Scheme&lt;/td&gt;
      &lt;td&gt;An implementation of the binary GCD algorithm for computing greatest common divisors of nonnegative integers.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Knuth-Morris-Pratt Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=knuth-morris-pratt&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;An implementation of the Knuth-Morris-Pratt algorithm for fast string matching.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Kadane’s Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=kadane&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of Kadane’s algorithm for solving the maximum-weight subarray problem.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Karatsuba’s Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=karatsuba&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;An implementation of Karatsuba’s algorithm for fast integer multiplication.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Min-Stack&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=min-stack&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a LIFO stack that supports O(1) push, pop, and find-minimum.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Random Bag&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=random-bag&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;A data structure that supports insertion and removal of a uniformly-random element.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Min-Queue&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=min-queue&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of a FIFO queue that supports O(1) push, pop, and find-minimum.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Lights-Out Solver&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=lights-out&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A solver for the game Lights Out using Gaussian elimination over GF(2).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Maximum Single-Sell Profit&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=single-sell-profit&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;Four algorithms for the maximum single-sell profit problem, each showing off a different algorithmic technique.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Generalized Kadane’s Algorithm&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=generalized-kadane&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;A generalization of Kadane’s algorithm for solving the maximum subarray problem subject to a length restriction.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Longest Range&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=longest-range&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An algorithm for solving the longest contiguous range problem.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Egyptian Fractions&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=egyptian-fraction&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;An implementation of the greedy algorithm for finding Egyptian fractions.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LL(1) Parser Generator&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=ll1&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An LL(1) parser generator.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LR(0) Parser Generator&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=lr0&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An LR(0) parser generator.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Word Ladders&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=word-ladder&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;JavaScript&lt;/td&gt;
      &lt;td&gt;A program for finding word ladders between two words.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alias Method&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=alias-method&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An implementation of the alias method for sampling from a discrete probability distribution.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Binary Quicksort&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=binary-quicksort&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An implementation of the binary quicksort (binary MSD radix sort) algorithm.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ternary Sierpinski Triangle&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=ternary-sierpinski&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;JavaScript&lt;/td&gt;
      &lt;td&gt;An algorithm for drawing the Sierpinksi triangle using ternary numbers.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;In-Place Tree Delete&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=inplace-tree-delete&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;C++&lt;/td&gt;
      &lt;td&gt;An algorithm for deleting all of the nodes of a binary tree using O(1) auxiliary storage space.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Random Access List&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=random-access-list&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Haskell&lt;/td&gt;
      &lt;td&gt;A purely functional, persistent random-access sequence backed by a random access list.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BST LCA&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=bst-lca&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Haskell&lt;/td&gt;
      &lt;td&gt;A function for finding the lowest common ancestor of two nodes in a binary search tree.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Matrix Fill&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=matrix-fill&quot;&gt;link&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;An algorithm for solving the matrix fill problem, an interview problem from Microsoft.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
    <link>https://dyxu.net/%E6%8A%80%E6%9C%AF/keith-schwarz.html</link>
    <guid>https://dyxu.net/%E6%8A%80%E6%9C%AF/keith-schwarz</guid>
    <pubDate>Mon, 04 Jul 2016 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>C++11新特性</title>
    <description>
&lt;blockquote&gt;
  &lt;p&gt;C++11是曾经被叫做C++0x，是对目前C++语言的扩展和修正，C++11不仅包含核心语言的新机能，而且扩
展了C++的标准程序库（STL），并入了大部分的C++ Technical Report 1（TR1）程序库(数学的特殊
函数除外)。&lt;/p&gt;

  &lt;p&gt;C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进。
编译器通过添加 &lt;code&gt;-std=c++11&lt;/code&gt; 或者 &lt;code&gt;-std=c++0x&lt;/code&gt; 参数来支持C++11。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;核心语言运行时性能强化&quot;&gt;核心语言运行时性能强化&lt;/h2&gt;

&lt;p&gt;以下特性基本上用于提升程序运行时的性能。&lt;/p&gt;

&lt;h3 id=&quot;右值引用和move语义&quot;&gt;右值引用和move语义&lt;/h3&gt;

&lt;p&gt;右值引用(R-values)是C++11标准中一个令人难以捉摸的特性。在Ｃ语言时代，左值和右值的定义如下：
&lt;strong&gt;左值是一个可以出现在赋值运算符左边或者右边的表达式exp，而右值是只能出现在右边的表达式。&lt;/strong&gt;
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a = 1;  
int b = 2;
// a和b是左值
a = b;  // ok
b = a;  // ok

// a * b是右值
a * b = 11;   // error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在C++中由于自定义类型的引入使得上述的定义变得不那么准确，另一个较好的定义&lt;strong&gt;左值是一个指向某内存
空间的表达式，并且我们可以用&amp;amp;操作符获得该内存空间的地址，右值就是非左值的表达式。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a = 1;  // ok
int *ptr = &amp;amp;a; // ok
int&amp;amp; func();
func() = 42;  // ok
// ptr, a和func()都是左值

int rfunc();
int *ptr1 = &amp;amp;rfunc(); // error rfunc()是右值
int *ptr = &amp;amp;42; // error 42是右值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;右值引用的加入主要是为了解决move语义和完美转发。&lt;/p&gt;

&lt;p&gt;(未完待续)&lt;/p&gt;

&lt;h3 id=&quot;常量表达式constexpr&quot;&gt;常量表达式constexpr&lt;/h3&gt;

&lt;p&gt;C++11中引入了新的关键字constexpr，其语义是“常量表达式”，即在编译期间可以求值的表达式。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;constexpr int func(int t) {
    return t + 1;
}

constexpr int a = func(1);  // ok
constexpr int b = func(cin.get()); // error
constexpr int c = a * 2 + 3; // ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;constexpr还可以用于修饰类的构造函数，在保证如果提供给构造函数的参数都是constexpr的前提下，那
么产生的对象中的所有成员都会是constexpr，可用于各种只能使用constexpr对象的场合。&lt;/p&gt;

&lt;h2 id=&quot;核心语言编译期间的加强&quot;&gt;核心语言编译期间的加强&lt;/h2&gt;

&lt;h3 id=&quot;外部模板&quot;&gt;外部模板&lt;/h3&gt;

&lt;p&gt;在标准C++中，在编译过程中需要对出现的每一处模板进行实例化；链接时，链接器还要移除重复的实例化代
码，有时候这会大大增加编译和链接的时间。而在C++中已经有强制编译器在特定位置进行实例化的语法了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template class std::vector&amp;lt;MyClass&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在C++11中简单地加入了外部模板的语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extern template class std::vector&amp;lt;MyClass&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// func.h
template &amp;lt;typename T&amp;gt;
void func(T t) { }

// src1.cpp
void test0() {
    func&amp;lt;int&amp;gt;(1);
}

// src2.cpp
extern template void func&amp;lt;int&amp;gt;(int);
void test1() {
    func&amp;lt;int&amp;gt;(1);
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;核心语言使用性的加强&quot;&gt;核心语言使用性的加强&lt;/h2&gt;

&lt;h3 id=&quot;统一初始化语法&quot;&gt;统一初始化语法&lt;/h3&gt;

&lt;p&gt;C++11用大括号统一了初始化的方法。&lt;/p&gt;

&lt;p&gt;对于POD类型(&lt;a href=&quot;https://zh.wikipedia.org/wiki/POD_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)&quot;&gt;Plain Old Data&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int arr[3] = {1, 2, 3};
struct tm today = {0};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在类(class/struct)是极简的、属于标准布局，以及它的所有非静态变量成员都是POD时，会被识别为POD。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;struct A { int m; }; // POD
struct B { ~B(); int m; }; // non-POD
struct C { C() : m() {}; ~(); int m; }; // non-POD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于POD类型如上述中类A, &lt;code&gt;new A&lt;/code&gt;和&lt;code&gt;new A()&lt;/code&gt;是不一样的，前者m没有被初始化话，后者被初始化了。
而对于non-POD类型，两种方式m都会被初始化。因此，在C++11中对初始化进行了统一。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int * nums = new int[3]{1, 2, 3}; // C++11 only
class X {
  private:
    int nums_[4];
  public:
    X() : nums_{1, 2, 3, 4} {} // C++11 only
};
   
vector&amp;lt;string&amp;gt; vs = {&quot;first&quot;, &quot;second&quot;, &quot;third&quot;};
map&amp;lt;string, string&amp;gt; user = {
    {&quot;Lady Gaga&quot;, &quot;123456789&quot;},
    {&quot;Michael Joseph&quot;, &quot;987654321&quot;}};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;类型推导&quot;&gt;类型推导&lt;/h3&gt;

&lt;p&gt;在标准C++和C中，使用变量定义时必须指明其类型。但是在模板编程中有时候函数的返回值难以确定，为了
解决上述的问题，C++11引入了两个新的关键字: auto和decltype。 auto的示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;auto a = 0;   // int
auto b = 'b'; // char
vecotr&amp;lt;string&amp;gt; vs;
auto it = vs.begin(); // vector&amp;lt;string&amp;gt;::const_iterator 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;decltype用于评估括号内的类型，对于decltype(expr)其规则如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果表达式expr是一个变量，那么代表该变量的类型。&lt;/li&gt;
  &lt;li&gt;如果表达式expr是一个函数，那么代表函数返回值的类型。&lt;/li&gt;
  &lt;li&gt;如果不符合1和2，如果expr是左值，类型为T，那么decltype(e)是T&amp;amp;；如果是右值，则是T。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename X, typename Y&amp;gt;
auto z = [](X x, Y y)-&amp;gt;decltype(x+y) { return x + y;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;基于范围的for循环&quot;&gt;基于范围的for循环&lt;/h3&gt;

&lt;p&gt;直接上示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int arr[3] = {1, 2, 3};
for(const int&amp;amp; e : arr) {
    std::cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; std::endl;
}

for(auto&amp;amp; e : arr) { // or auto&amp;amp; e =&amp;gt; int&amp;amp; e
    e &amp;amp;= 0xFF;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lambda-表达式&quot;&gt;Lambda 表达式&lt;/h3&gt;

&lt;p&gt;C++11中引入了Lambda表达式，既匿名函数。其语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;[capture](parameters) -&amp;gt; return_type { body }
[]  // body中不能引用外部变量
[=] // body中外部变量以值传递的形式传入
[&amp;amp;] // body中外部变量以引用的形式传入
[x, &amp;amp;y]  // body中x值传递的形式传入，y为引用传入
[&amp;amp;, x] // body中除了x为值传递外其他都是引用传递
[=, &amp;amp;x] // body除x为引用传递外，其他外部变量都是值传递
-&amp;gt;return_type // 为可选项
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int sum = 0;
vector&amp;lt;int&amp;gt; v{1, 2, 3};
for_each(v.begin(), v.end(), [&amp;amp;sum](int x) {
    sum += x;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;返回值后置的函数定义&quot;&gt;返回值后置的函数定义&lt;/h3&gt;

&lt;p&gt;在C++03中一下代码是不合法的，因为ReturnType的类型必须在x+y的结果出来后才能确定。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename X, typename Y&amp;gt;
ReturnType Func(const X&amp;amp; x, const Y&amp;amp; y) { 
    return x + y; // ReturnType 必须是x + y类型
} 

template &amp;lt;typename X, typename Y&amp;gt;
decltype(x+y) Func(const X&amp;amp; x, const Y&amp;amp; y) { 
    return x + y;
} // error: x和y的定义编译器在分析到函数原型的后半部分时才出现
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++11引入了一种新的函数定义声明语法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename X, typename Y&amp;gt;
auto Func(const X&amp;amp; x, const Y&amp;amp; y) -&amp;gt; decltype(x+y) { 
    return x + y; // ok
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;委托构造&quot;&gt;委托构造&lt;/h3&gt;

&lt;p&gt;在以前版本的C++中，构造函数之间不能相互调用。如果要写内容相似的构造函数就必须把相同的内容放到私
有的成员函数中，并且基类的构造函数不能直接成为派生类的构造函数，即使它已经够用了。C++11中允许构
函数调用其他构造函数，称为委托构造。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class User {
  public:
    User() : User(&quot;None&quot;, 0){}
    User(string name) : User(name, 0) {}
    User(string name, ulong id) : name_(name), id_(id) {}

  private:
    string name_;
    ulong  id_;
};

class Student : public User{
  public:
    using User::User;

  private:
   string school = &quot;xmu&quot;; // c++11 only
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;虚函数重载&quot;&gt;虚函数重载&lt;/h3&gt;

&lt;p&gt;在C++里面，派生类容易意外地重载虚函数，比如说&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class Base {
  public:
    virtual void Func();
};

class Derived: Base {
  public:
    void Func();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时如果基类Base中的虚函数签名被改变，那么派生类将不再重载虚函数，程序员很可能不会注意到这个问
题，从而导致错误的调用。&lt;/p&gt;

&lt;p&gt;C++11中加入override来防止上述情况的发生，并在编译期间捕获此类错误，该功能是向下兼容的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class Base {
  public:
    virtual void Func();
};

class Derived: Base {
  public:
    virtual void Func() override; //ok
    virtual void Func(int) override; // error
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++11中还提供了关键字final来防止类被继承或是函数被重载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class Base final {};
class Derived : public Base {}; // error: Base is marked as final

class User {
  public:
    virtual void Func() final;
};

class Student {
  public:
    virtual void Func();  // error
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;空指针nullptr&quot;&gt;空指针nullptr&lt;/h3&gt;

&lt;p&gt;在C语言中空指针NULL被定义为&lt;code&gt;((void*)0)&lt;/code&gt;或是0。在C++中不允许&lt;code&gt;void*&lt;/code&gt;隐式转换为别的类型的指针，
为了使代码&lt;code&gt;char *ptr = NULL&lt;/code&gt;通过编译，NULL只能被设为0。这就出现了一些无法区分代码语义的情况。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void Func(char *);
void Func(int);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你调用Func(NULL)时，想调用上者，实际上将调用的却是Func(int)函数。C++11中引入的空指针nullptr，
nullptr的类型为nullptr_t，可以隐式地转换成任何指针类型，也可以进行相等或不等的比较，但不能隐
式转换成整数，也不能与整数进行比较。&lt;/p&gt;

&lt;h3 id=&quot;强枚举类型&quot;&gt;强枚举类型&lt;/h3&gt;

&lt;p&gt;在标准C++中，枚举类型不是类型安全的。枚举类型被视为整型，这使得不同类型之间可以比较。此外枚举类型
所使用的整型的类型无法确定。最重要的是枚举类型名暴露在一般范围中，两个不同的枚举类型不能拥有相同的
枚举名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;enum Side{ LEFT, RIGHT};
enum Dir { UP, DOWN, LEFT, RIGHT}; // error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++11中需要为枚举类型提供类型，默认为int类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;enum Enum1;  // error
enum Enum2 : unsigned int; // c++11 only
enum class Enum3; // c++11 only, default(int)
enum class Enum4 : unsigned int; // c++11 only
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;角括号修正&quot;&gt;角括号修正&lt;/h3&gt;

&lt;p&gt;C++11的编译器可以更好地解析右角括号的语法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;std::vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; v; // error with C++03 but ok with C++11
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;核心语言能力的提升&quot;&gt;核心语言能力的提升&lt;/h2&gt;

</description>
    <link>https://dyxu.net/%E6%8A%80%E6%9C%AF/cpp-11.html</link>
    <guid>https://dyxu.net/%E6%8A%80%E6%9C%AF/cpp-11</guid>
    <pubDate>Mon, 04 Jul 2016 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>Shell简明教程 1</title>
    <description>
&lt;h2 id=&quot;shell脚本语法&quot;&gt;Shell脚本语法&lt;/h2&gt;

&lt;p&gt;Shell中一条语句一行，如果想把多条语句写在同一行，则用分号;隔开。&lt;/p&gt;

&lt;h3 id=&quot;变量&quot;&gt;变量&lt;/h3&gt;

&lt;p&gt;Shell中的变量是“弱”变量，正常情况下，被保存字符串，若要进行数学运算需要进行转换，如$((EXPR))。变量名的格式和C语言中相同
通过&lt;code&gt;NAME=VALUE&lt;/code&gt;定义变量，&lt;code&gt;unset NAME&lt;/code&gt;来清除变量。Shell中提供了丰富的变量操作语法，如下图所示(图片取自
&lt;a href=&quot;http://www.cnblogs.com/barrychiao/archive/2012/10/22/2733210.html&quot;&gt;博客&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/04/shell_var_op0.png&quot; alt=&quot;图片&quot; /&gt;
&lt;img src=&quot;/images/2016/04/shell_var_op1.png&quot; alt=&quot;图片&quot; /&gt;
&lt;img src=&quot;/images/2016/04/shell_var_op2.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Shell还定义了一些系统环境变量和特殊的变量，环境变量用&lt;code&gt;env&lt;/code&gt;指令查看，特殊变量如下表所示&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;特殊变量&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;含义&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;$num&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;num=0…n，含义等同于C语言中argv[num]，表示参数表&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;$#&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;等于argc - 1,表示参数个数&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;$@&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;表示参数列表”$1”,”$2”…&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;$*&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;表示参数列表”$1 $2 $3 …“（注意和$@的区别）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;$?&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;上一条指令的执行状态&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;$$&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;当前进程号&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;$_&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;之前命令的最后一个参数&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;条件测试&quot;&gt;条件测试&lt;/h3&gt;

&lt;p&gt;条件测试语句关键词是&lt;code&gt;test&lt;/code&gt; 或 &lt;code&gt;[  ]&lt;/code&gt;，二者等效。需要特别注意的是，如果测试为真，&lt;strong&gt;返回0&lt;/strong&gt;;否则返回为1（这点正好和C语言中
相反）。参数表及其含义如下&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;命令&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;含义&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ -d DIR ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;DIR存在且为一个目录则为真&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ -f FILE ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;FILE存在且为一个普通文件则为真&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ -z STRING ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;STRING长度为0则为真&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ -n STRING ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;STRING长度非0则为真&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ STRING1 = STRING2 ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;如果两个字符串相等则为真&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ STRING1 != STRING2 ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;如果两个字符串不等则为真&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ ARG1 OP ARG2 ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;满足OP条件则为真，其中参数的值必须是整数，OP操作可以是-eq、-ne、-lt、-le、-gt、-ge&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ ! EXPR ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;取非&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ EXPR1 -a EXPR2 ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;且关系&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[ EXPR1 -o EXPR2 ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;或关系&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ -f ~/.bashrc ]; then
    source ~/.bashrc
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;分支控制&quot;&gt;分支控制&lt;/h3&gt;

&lt;p&gt;Shell中用if、then、elif、else和fi来进行分支控制，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if :; then
    echo &quot;always true&quot;
    echo &quot;continue...&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中:是一个特殊的指令，它什么也不执行，但返回为真。或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;enter a filename or dirname: &quot;
read STRING
if [ -f &quot;$STRING&quot; ]; then
    echo &quot;$STRING is a file&quot;
elif [ -d &quot;$STRING&quot; ]; then
    echo &quot;$STRING is a directory&quot;
else
    echo &quot;Error&quot;
    exit 1
fi
exit 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，Shell也支持&amp;amp;&amp;amp;和||操作，含义和C语言中相同且同样支持短路特性。与之前&lt;code&gt;test&lt;/code&gt;语句中-a和-o参数的不同是后者只能用在测试
命令中。&lt;/p&gt;

&lt;p&gt;另外，Shell还提供了case语句来进行分支控制，与C语言中switch语句不同的是，条件匹配后不需要用break跳出，而是执行完特定语句
后自动跳到esac。case语句支持通配符，含义如下:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;通配符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;含义&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;匹配任意0个或多个字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;？&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;匹配任意一个字符&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;[  ]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;匹配方括号内单个字符，例如用[A-Za-z]匹配一个字母&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;case语句的语法用一个例子阐述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;enter a single char: &quot;
read CHAR
case &quot;$CHAR&quot; in
    [A-Za-z])
        echo &quot;$CHAR is a letter&quot;;;
    1 | 2 | 3)
        echo &quot;$CHAR is a specified number&quot;;;
    *)
        echo &quot;this an else-case&quot;;;
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;循环语句&quot;&gt;循环语句&lt;/h3&gt;

&lt;p&gt;Shell中提供了三中的循环语句:while、until和for语句，其中前两个和C语言中的while和do…while类似，而for语句则更像是python中
的for语句，它们的语法分别用三个例子来阐述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# while statement
CNT=0
while [ &quot;$CNT&quot; -lt 10]; do
    echo &quot;$CNT&quot;
    CNT=$(($CNT + 1))
done

# until statement
CNT=0
until [ &quot;$CNT&quot; -be 10]; do
    echo &quot;$CNT&quot;
    CNT=$(($CNT + 1))
done

# for statement
for FILE in `ls .`; do
    echo &quot;operations on $(FILE)&quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;

&lt;p&gt;Shell中的函数不带任何参数, 通过$num来传递参数，用return提供0-255区间的返回值，在函数调用后用&lt;code&gt;$?&lt;/code&gt;查看，在函数体内可以用
&lt;code&gt;local name=vale&lt;/code&gt;定义局部变量，而变量的作用域和C语言中相同–局部覆盖全局，具体语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func_name ()
{
    statement
    [return int]
}

num=10
print_num() 
{
    local num=100
    num=$((num+1))
    echo &quot;local num=$num, paras: $@&quot;
    return $num
}

print_num 1 2 3   # =&amp;gt; local num=101, paras: 1 2 3
echo &quot;$?&quot;         # =&amp;gt; 101
echo $num         # =&amp;gt; 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;shell调试&quot;&gt;Shell调试&lt;/h2&gt;

&lt;p&gt;Shell运行脚本时可以通过下列参数进行调试&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;参数&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;作用&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;读一遍脚本中的命令但不执行，用于语法检查&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;一边执行脚本，一边将执行过的指令打印到标准错误&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;-x&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;跟踪执行信息，将执行的每一条命令和结果依次打印&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;而设置这些选项有以下三种方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在命令行中提供参数 &lt;code&gt;sh -x test.sh&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在脚本开头提供     &lt;code&gt;#! /bin/sh -x&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在脚本中利用set开关参数 &lt;code&gt;set -x&lt;/code&gt; 和 &lt;code&gt;set +x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
    <link>https://dyxu.net/%E6%8A%80%E6%9C%AF/shell-learning-1.html</link>
    <guid>https://dyxu.net/%E6%8A%80%E6%9C%AF/shell-learning-1</guid>
    <pubDate>Sat, 16 Apr 2016 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>Shell简明教程 0</title>
    <description>
&lt;h2 id=&quot;shell配置&quot;&gt;Shell配置&lt;/h2&gt;

&lt;h3 id=&quot;bash-shell启动配置文件&quot;&gt;Bash Shell启动配置文件&lt;/h3&gt;

&lt;p&gt;用户在登录shell时，会执行相应的配置文件，对shell进行配置和定制。主要分为三种类型&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户登录主机时，loginshell先执行/etc/profile，接着依次检查用户主目录是否有.bash_profile 或 .bash_login 或 .profile
文件，若存在，则执行且只执行其中的一个。&lt;/li&gt;
  &lt;li&gt;在登录后执行shell时，分为两种情况：
    &lt;ol&gt;
      &lt;li&gt;执行交付式的shell。例如打开终端，此时bash会以此执行/etc/bash.bashrc和主目录下.bashrc文件。&lt;/li&gt;
      &lt;li&gt;执行shell脚本。例如sh test.sh，此时bash会检测BASH_ENV变量的内容，如果该变量有定义，就执行所提供的配置文件的内容。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后需要注意的是：shell注销后，其主目录下.bash_logout文件会被执行，类似析构函数的作用。&lt;/p&gt;

&lt;h3 id=&quot;管理shell配置文件&quot;&gt;管理Shell配置文件&lt;/h3&gt;

&lt;p&gt;对于管理员，可以通过修改以下三个文件或目录统一管理shell的配置&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;/etc/profile 只要用户登录，都要执行&lt;/li&gt;
  &lt;li&gt;/etc/bash.bashrc 所有用户启动交互式shell时都要执行&lt;/li&gt;
  &lt;li&gt;/etc/skel/ 该目录中存放着.bash_logout、.bashrc和.profile文件，当新用户被创建时，这三个文件就会被拷贝到其主目录下作为
默认配置文件&lt;/li&gt;
&lt;/ol&gt;
</description>
    <link>https://dyxu.net/%E6%8A%80%E6%9C%AF/shell-learning-0.html</link>
    <guid>https://dyxu.net/%E6%8A%80%E6%9C%AF/shell-learning-0</guid>
    <pubDate>Sat, 16 Apr 2016 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>github pages中插入带caption的图片</title>
    <description>
&lt;h3 id=&quot;1-最终效果&quot;&gt;1 最终效果&lt;/h3&gt;

&lt;p&gt;本文讨论一种在github pages中插入带caption图片的实现方式，最终的效果如图一所示&lt;/p&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
    &lt;a href=&quot;https://dyxu.net&quot; title=&quot;最终效果&quot; target=&quot;_blank&quot;&gt;
    
        &lt;img src=&quot;/images/2016/04/duang.jpg&quot; alt=&quot;最终效果&quot; /&gt;
    
    &lt;/a&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;图一 最终效果&lt;/p&gt;
    
&lt;/div&gt;

&lt;h3 id=&quot;2-实现方法&quot;&gt;2 实现方法&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;21-_includes中插入imagehtml模板&quot;&gt;2.1 _includes中插入image.html模板&lt;/h4&gt;

&lt;p&gt;在_includes目录下创建image.html文件，写入以下内容&lt;/p&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/images/2016/04/image_html.jpg&quot; alt=&quot;image.html模板&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;图二 image.html代码&lt;/p&gt;
    
&lt;/div&gt;

&lt;h4 id=&quot;22-加入css样式&quot;&gt;2.2 加入CSS样式&lt;/h4&gt;

&lt;p&gt;将图片显示的CSS样式加入网站的样式中，我的目录为assets/css/style.css，内容为(按自己喜好修改)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.image-wrapper {
    text-align: center;

    .image-caption {
        color: $grey-color;
        margin-top: $spacing-unit / 3;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;23-应用样式&quot;&gt;2.3 应用样式&lt;/h4&gt;

&lt;p&gt;在文章需要插入图片的位置，用以下方式插入图片即可&lt;/p&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
        &lt;img src=&quot;/images/2016/04/insert_image.jpg&quot; alt=&quot;插入图片例程&quot; /&gt;
    
    
        &lt;p class=&quot;image-caption&quot;&gt;图三 插入图片例程&lt;/p&gt;
    
&lt;/div&gt;

</description>
    <link>https://dyxu.net/%E5%B7%A5%E5%85%B7/insert-image-with-caption.html</link>
    <guid>https://dyxu.net/%E5%B7%A5%E5%85%B7/insert-image-with-caption</guid>
    <pubDate>Fri, 15 Apr 2016 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>MathJax:网页中显示精美公式</title>
    <description>
&lt;h3 id=&quot;mathjax是什么&quot;&gt;MathJax是什么？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;MathJax是一个开源JavaScript库。它支持LaTeX、MathML、AsciiMath符号，可以运行于所有流行浏览器上。 
它的设计目标是利用最新的web技术，构建一个支持math的web平台。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MathJax是一款帮你在网页上快捷地显示漂亮公式的引擎，支持LaTex、MathML、AsciiMath等语法。本教程教大家如何使用
这个工具。&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;MathJax的安装方式十分便捷，只要把官方提供的JavaScript的代码插入到网页中便可。（特别是用Jekyll在github上搭建博客的朋友，可以直接将以下这段代码复制到_includes/default.html的head标签内。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;
	src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;markdown中使用mathjax引擎&quot;&gt;Markdown中使用MathJax引擎&lt;/h3&gt;

&lt;p&gt;用MathJax引擎处理Markdown中的公式时，*.md文件依次经过了markdown引擎和MathJax引擎的解析，而\在前者中是转移字符，所以要用\\代替在MathJax中的\，因此通过以下方式插入公式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$$公式$$         ==&amp;gt;行间公式(相当于latex的\begin{math}公式\end{begin})
\\(公式\\)       ==&amp;gt;行内公式(相当于latex的\begin{displaymath}公式\end{displaymath})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如正态分布&lt;code&gt;f(x) = \frac{1}{\sigma \sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}&lt;/code&gt;MathJax解析后显示如下:&lt;/p&gt;

\[f(x) = \frac{1}{\sigma \sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\]

&lt;p&gt;而公式内的语法和LaTex相同(详情参见&lt;a href=&quot;http://mohu.org/info/symbols/symbols.htm&quot;&gt;常用数学符号的LaTeX表示方法&lt;/a&gt;）,并且这些公式并不是图片，可以将鼠标移至图片上方进行&lt;strong&gt;复制Tex代码&lt;/strong&gt;等操作。&lt;/p&gt;

&lt;h3 id=&quot;公式引用&quot;&gt;公式引用&lt;/h3&gt;

&lt;p&gt;MathJax从2.0版本开始支持公式编号和引用。在公式内&lt;code&gt;\begin{equation}...\end{equation}&lt;/code&gt;之间插入&lt;code&gt;\label{id}&lt;/code&gt;给公式编号，然后在合适的地方&lt;code&gt;\eqref{id}&lt;/code&gt;即引用该公式。但是MathJax的默认设置中并没有加入这两个特性，需要在网页的head标签内加入以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/x-mathjax-config&quot;&amp;gt;
		MathJax.Hub.Config({
    	TeX: {equationNumbers: {autoNumber: [&quot;AMS&quot;], useLabelIds: true}},
    	&quot;HTML-CSS&quot;: {linebreaks: {automatic: true}},
    	SVG: {linebreaks: {automatic: true}}
 		});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以为公式加编号和引用，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$$ \begin{equation}J_\alpha(x) = \sum_{m=0}^\infty\frac{(-1)^m}{m!\Gamma(m+\alpha+1)} {\left({\frac{x}{2}}\right)}^{2m+\alpha}\label{J}\end{equation} $$
&lt;/code&gt;&lt;/pre&gt;

\[\begin{equation} J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha}\label{J}\end{equation}\]

&lt;p&gt;通过&lt;code&gt;\eqref{J}&lt;/code&gt;引用上面的公式\eqref{J}。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    <link>https://dyxu.net/%E5%B7%A5%E5%85%B7/tmathjax-webpage-display-formula.html</link>
    <guid>https://dyxu.net/%E5%B7%A5%E5%85%B7/tmathjax-webpage-display-formula</guid>
    <pubDate>Thu, 21 Jan 2016 00:00:00 +0000</pubDate>
  </item>

  <item>
    <title>2015年阅读书单</title>
    <description>
</description>
    <link>https://dyxu.net/%E9%98%85%E8%AF%BB/Book-List-2015.html</link>
    <guid>https://dyxu.net/%E9%98%85%E8%AF%BB/Book-List-2015</guid>
    <pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate>
  </item>


</channel>
</rss>
